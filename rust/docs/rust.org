* Intro
#+BEGIN_SRC rust
fn main(){
    println!("hello world");
}
#+END_SRC

#+RESULTS:
: hello World

* Variables
#+BEGIN_SRC rust  
let name = "John";
let age = 30;
println!("{} is {} years old.", name, age); 
#+END_SRC

#+RESULTS:
: John is 30 years old.


#+BEGIN_SRC rust  
let mut x = 5;
println!("Before: {}", x);
x = 10;
println!("After: {}", x); 
#+END_SRC

#+RESULTS:
: Before: 5
: After: 10

* Data Types
#+BEGIN_SRC rust  
let age: i32 = 25;
println!("Age is: {}", age); 
#+END_SRC

#+RESULTS:
: Age is: 25


#+BEGIN_SRC rust  
let price: f64 = 19.99;
println!("Price is: ${}", price); 
#+END_SRC

#+RESULTS:
: Price is: $19.99


#+BEGIN_SRC rust  
let my_grade: char = 'B';
println!("{}", my_grade); 
#+END_SRC

#+RESULTS:
: B


#+BEGIN_SRC rust  
let name: &str = "John";
println!("Hello, {}!", name); 
#+END_SRC

#+RESULTS:
: Hello, John!


#+BEGIN_SRC rust  
let is_logged_in: bool = true;
println!("User logged in? {}", is_logged_in); 
#+END_SRC

#+RESULTS:
: User logged in? True

* Constant
#+BEGIN_SRC rust  
const BIRTHYEAR: i32 = 1980;
const MINUTES_PER_HOUR: i32 = 60;
#+END_SRC

#+Results:

* Operators
#+BEGIN_SRC rust  
fn main() {
  let add = 5 + 3;
  let sub = 10 - 4;
  let mul = 6 * 2;
  let div = 12 / 3;
  let rem = 10 % 3;

  println!("Add: {}", add);
  println!("Sub: {}", sub);
  println!("Mul: {}", mul);
  println!("Div: {}", div);
  println!("Rem: {}", rem);
}
#+END_SRC

#+RESULTS:
: Add: 8
: Sub: 6
: Mul: 12
: Div: 4
: Rem: 1


#+BEGIN_SRC rust  
fn main() {
  let mut x = 10;
  println!("Start: {}", x);

  x += 5;
  println!("After += 5: {}", x);

  x -= 2;
  println!("After -= 2: {}", x);

  x *= 2;
  println!("After *= 2: {}", x);

  x /= 3;
  println!("After /= 3: {}", x);

  x %= 4;
  println!("After %= 4: {}", x);
}
#+END_SRC

#+RESULTS:
: Start: 10
: After += 5: 15
: After -= 2: 13
: After *= 2: 26
: After /= 3: 8
: After %= 4: 0

* Booleans
#+BEGIN_SRC rust  
fn main() {
  let a = 5;
  let b = 10;

  println!("5 == 10: {}", a == b);
  println!("5 != 10: {}", a != b);
  println!("5 < 10: {}", a < b);
  println!("5 >= 10: {}", a >= b);
}
#+END_SRC

#+RESULTS:
: 5 == 10: false
: 5 != 10: true
: 5 < 10: true
: 5 >= 10: false


#+BEGIN_SRC rust  
fn main() {
  let logged_in = true;
  let is_admin = false;

  println!("Is regular user: {}", logged_in && !is_admin);
  println!("Has any access: {}", logged_in || is_admin);
  println!("Not logged in: {}", !logged_in);
}
#+END_SRC

#+RESULTS:
: Is regular user: true
: Has any access: true
: Not logged in: false


#+BEGIN_SRC rust  
let is_programming_fun: bool = true;
let is_fish_tasty: bool = false;

println!("Is Programming Fun? {}", is_programming_fun);
println!("Is Fish Tasty? {}", is_fish_tasty);
#+END_SRC

#+RESULTS:
: Is Programming Fun? true
: Is Fish Tasty? false


#+BEGIN_SRC rust  
let is_programming_fun = true;
let is_fish_tasty = false;

println!("Is Programming Fun? {}", is_programming_fun);
println!("Is Fish Tasty? {}", is_fish_tasty);
#+END_SRC

#+RESULTS:
: Is Programming Fun? true
: Is Fish Tasty? false


#+BEGIN_SRC rust  
let age = 20;
let can_vote = age >= 18;

println!("Can vote? {}", can_vote); 
#+END_SRC

#+RESULTS:
: Can vote? true


#+BEGIN_SRC rust  
let is_logged_in = true;

if is_logged_in {
  println!("Welcome back!");
} else {
  println!("Please log in.");
}
#+END_SRC

#+RESULTS:
: Welcome Back!

* Conditions
#+BEGIN_SRC rust  
let x = 7;
let y = 5;

if x > y {
  println!("x is greater than y.");
} 
#+END_SRC

#+RESULTS:
: x is greater than y.


#+BEGIN_SRC rust  
let age = 16;

if age >= 18 {
  println!("You can vote.");
} else {
  println!("You are too young to vote.");
} 
#+END_SRC

#+RESULTS:
: You are too young to vote.


#+BEGIN_SRC rust  
let score = 85;

if score >= 90 {
  println!("Grade: A");
} else if score >= 80 {
  println!("Grade: B");
} else if score >= 70 {
  println!("Grade: C");
} else {
  println!("Grade: F");
}
#+END_SRC

#+RESULTS:
: Grade: B


#+BEGIN_SRC rust  
let time = 20;
let greeting = if time < 18 {
  "Good day."
} else {
  "Good evening."
};
println!("{}", greeting);
#+END_SRC

#+RESULTS:
: Good evening.


#+BEGIN_SRC rust  
let number = 5;
let result = if number < 10 { "Too small" } else { 100 };
println!("{}", result);
#+END_SRC

#+Results:

* Match
#+BEGIN_SRC rust  
fn main() {
    let day = 4;

    match day {
	1 => println!("Monday"),
	2 => println!("Tuesday"),
	3 => println!("Wednesday"),
	4 => println!("Thursday"),
	5 => println!("Friday"),
	6 => println!("Saturday"),
	7 => println!("Sunday"),
	_ => println!("Invalid day."),
    }
}
#+END_SRC

#+RESULTS:
: Thursday


#+BEGIN_SRC rust  
fn main() {
  let day = 6;

  match day {
    1 | 2 | 3 | 4 | 5 => println!("Weekday"),
    6 | 7 => println!("Weekend"),
    _ => println!("Invalid day"),
  }
}
#+END_SRC

#+RESULTS:
: Weekend


#+BEGIN_SRC rust  
fn main() {
  let day = 4;

  let result = match day {
    1 => "Monday",
    2 => "Tuesday",
    3 => "Wednesday",
    4 => "Thursday",
    5 => "Friday",
    6 => "Saturday",
    7 => "Sunday",
    _ => "Invalid day.",
  };

  println!("{}", result);
} 
#+END_SRC

#+RESULTS:
: Thursday

* Loops
#+BEGIN_SRC rust  
let mut count = 1;

loop {
  println!("Hello World!");

  if count == 3 {
    break;
  }

  count += 1;
} 
#+END_SRC

#+RESULTS:
: Hello World!
: Hello World!
: Hello World!


#+BEGIN_SRC rust  
let mut count = 1;

let result = loop {
  println!("Hello!");

  if count == 3 {
    break count; // Stop the loop and return the number 3
  }

  count += 1;
};

println!("The loop stopped at: {}", result); 
#+END_SRC

#+RESULTS:
: Hello!
: Hello!
: Hello!
: The loop stopped at: 3

* While Loops
#+BEGIN_SRC rust  
let mut count = 1;

while count <= 5 {
  println!("Count: {}", count);
  count += 1;
}
#+END_SRC

#+RESULTS:
: Count: 1
: Count: 2
: Count: 3
: Count: 4
: Count: 5


#+BEGIN_SRC rust  
let mut num = 1;

while num <= 10 {
  if num == 6 {
    break;
  }
  println!("Number: {}", num);
  num += 1;
}
#+END_SRC

#+RESULTS:
: Number: 1
: Number: 2
: Number: 3
: Number: 4
: Number: 5


#+BEGIN_SRC rust  
let mut num = 1;

while num <= 10 {
  if num == 6 {
    num += 1;
    continue;
  }

  println!("Number: {}", num);
  num += 1;
}
#+END_SRC

#+RESULTS:
: Number: 1
: Number: 2
: Number: 3
: Number: 4
: Number: 5
: Number: 7
: Number: 8
: Number: 9
: Number: 10

* For Loops
#+BEGIN_SRC rust  
for i in 1..6 {
  println!("i is: {}", i);
}
#+END_SRC

#+RESULTS:
: i is: 1
: i is: 2
: i is: 3
: i is: 4
: i is: 5


#+BEGIN_SRC rust  
for i in 1..=6 {
  println!("i is: {}", i);
}
#+END_SRC

#+RESULTS:
: i is: 1
: i is: 2
: i is: 3
: i is: 4
: i is: 5
: i is: 6


#+BEGIN_SRC rust  
for i in 1..=10 {
  if i == 3 {
    continue; // skip 3
  }
  if i == 5 {
    break; // stop before printing 5
  }
  println!("i is: {}", i);
}
#+END_SRC

#+RESULTS:
: i is: 1
: i is: 2
: i is: 4

* Functions
#+BEGIN_SRC rust  
// Create a function
fn say_hello() {
  println!("Hello from a function!");
}

say_hello(); // Call the function 
#+END_SRC

#+RESULTS:
: Hello from a function!


#+BEGIN_SRC rust  
fn greet(name: &str) {
  println!("Hello, {}!", name);
}

greet("John");
#+END_SRC

#+RESULTS:
: Hello, John!


#+BEGIN_SRC rust  
fn add(a: i32, b: i32) -> i32 {
  return a + b;
}

let sum = add(3, 4);
println!("Sum is: {}", sum);
#+END_SRC

#+RESULTS:
: Sum is: 7


#+BEGIN_SRC rust  
fn add(a: i32, b: i32) -> i32 {
  a + b  // omit return
}

let sum = add(3, 4);
println!("Sum is: {}", sum);
#+END_SRC

#+RESULTS:
: Sum is: 7

* Scope
#+BEGIN_SRC rust  
let x = 5;

{
  let x = 10;
  println!("Inside block: {}", x);
}

println!("Outside block: {}", x);
#+END_SRC

#+RESULTS:
: Inside block: 10
: Outside block: 5

* Strings
#+BEGIN_SRC rust  
let greeting: &str = "Hello";
println!("{}", greeting); 
#+END_SRC

#+RESULTS:
: Hello


#+BEGIN_SRC rust  
let text1 = "Hello World".to_string();
println!("{}", text1)
#+END_SRC

#+RESULTS:
: Hello World


#+BEGIN_SRC rust  
let text2 = String::from("Hello World");
println!("{}", text2)
#+END_SRC

#+RESULTS:
: Hello World


#+BEGIN_SRC rust  
let mut greeting = String::from("Hello");
greeting.push_str(" World");
println!("{}", greeting); // Hello World 
#+END_SRC

#+RESULTS:
: Hello World


#+BEGIN_SRC rust  
 let mut word = String::from("Hi");
word.push('!');
println!("{}", word); // Hi!
#+END_SRC

#+RESULTS:
: Hi!


#+BEGIN_SRC rust  
let s1 = String::from("Hello");
let s2 = String::from("World!");
let s3 = String::from("What a beautiful day!");
let result = format!("{} {} {}", s1, s2, s3);
println!("{}", result);
#+END_SRC

#+RESULTS:
: Hello World! What a beautiful day!


#+BEGIN_SRC rust  
let s1 = String::from("Hello");
let s2 = String::from("World!");
let s3 = String::from("What a beautiful day!");
let result = s1 + " " + &s2 + " " + &s3;
println!("{}", result);
#+END_SRC

#+RESULTS:
: Hello World! What a beautiful day!


#+BEGIN_SRC rust  
let name = String::from("John");
println!("Length: {}", name.len()); // 4 
#+END_SRC

#+RESULTS:
: Length: 4

* Ownership
#+BEGIN_SRC rust  
let a = String::from("Hello");
let b = a;

// println!("{}", a); Error: a no longer owns the value
println!("{}", b); // Ok: b now owns the value 
#+END_SRC

#+RESULTS:
: Hello


#+BEGIN_SRC rust  
let a = 5;
let b = a;
println!("a = {}", a);  // Works
println!("b = {}", b);  // Works 
#+END_SRC

#+RESULTS:
: a = 5
: b = 5


#+BEGIN_SRC rust  
let a = String::from("Hello");
let b = a.clone(); // Now both have the same value

println!("a = {}", a);  // Works
println!("b = {}", b);  // Works 
#+END_SRC

#+RESULTS:
: a = Hello
: b = Hello

* Borrowing and References
#+BEGIN_SRC rust  
let a = String::from("Hello");
let b = &a;

println!("a = {}", a);
println!("b = {}", b); 
#+END_SRC

#+RESULTS:
: a = Hello
: b = Hello


#+BEGIN_SRC rust  
let mut name = String::from("John");
let name_ref = &mut name;
name_ref.push_str(" Doe");

println!("{}", name_ref); // John Doe 
#+END_SRC

#+RESULTS:
: John Doe

* Data Structures
** Arrays
#+BEGIN_SRC rust  
let fruits = ["apple", "banana", "orange"];
println!("Last fruit: {}", fruits[2]); 
#+END_SRC

#+RESULTS:
: Last fruit: Orange

** Vectors
#+BEGIN_SRC rust  
let mut fruits = vec!["apple", "banana"];
fruits.push("cherry");

println!("Last fruit: {}", fruits[2]); 
#+END_SRC

#+RESULTS:
: Last fruit: Cherry

** Tuples
#+BEGIN_SRC rust  
let person = ("John", 30, true);
println!("Name: {}", person.0);
println!("Age: {}", person.1);
println!("Is active: {}", person.2); 
#+END_SRC

#+RESULTS:
: Name: John
: Age: 30
: Is active: True

** HashMaps
#+BEGIN_SRC rust  
// Import HashMap
use std::collections::HashMap;

fn main() {
  let mut capital_cities = HashMap::new();
  capital_cities.insert("France", "Paris");
  capital_cities.insert("Japan", "Tokyo");

  println!("Capital of Japan is {}", capital_cities["Japan"]);
}
#+END_SRC

#+RESULTS:
: Capital of Japan is Tokyo

* Arrays
#+BEGIN_SRC rust  
let numbers = [1, 2, 3, 4, 5];
println!("The first number is: {}", numbers[0]);
#+END_SRC

#+RESULTS:
: The first number is: 1


#+BEGIN_SRC rust  
let mut numbers = [1, 2, 3, 4, 5];
numbers[0] = 10;
println!("The new first number is: {}", numbers[0]);
#+END_SRC

#+RESULTS:
: The new first number is: 10


#+BEGIN_SRC rust  
let numbers = [1, 2, 3, 4, 5];
println!("This array has {} elements.", numbers.len());
#+END_SRC

#+RESULTS:
: This array has 5 elements.


#+BEGIN_SRC rust  
let fruits = ["apple", "banana", "orange"];
for fruit in fruits {
  println!("I like {}.", fruit);
}
#+END_SRC

#+RESULTS:
: I like apple.
: I like banana.
: I like orange.


#+BEGIN_SRC rust  
let numbers = [1, 2, 3, 4, 5];
println!("{:?}", numbers); 
#+END_SRC

#+RESULTS:
: [1, 2, 3, 4, 5]


#+BEGIN_SRC rust  
let numbers = [1, 2, 3, 4, 5];
println!("{}", numbers[0]);
#+END_SRC

#+RESULTS:
: 1

* Vectors
#+BEGIN_SRC rust  
// A vector with 3 elements
let mut cars = vec!["Volvo", "BMW", "Ford"];

// Add another element
cars.push("Mazda");

println!("{:?}", cars); // ["Volvo", "BMW", "Ford", "Mazda"] 
#+END_SRC

#+RESULTS:
: ["Volvo", "BMW", "Ford", "Mazda"]


#+BEGIN_SRC rust  
let fruits = vec!["apple", "banana", "orange"];
println!("First fruit: {}", fruits[0]);
#+END_SRC

#+RESULTS:
: First fruit: apple


#+BEGIN_SRC rust  
let mut fruits = vec!["apple", "banana", "orange"];
fruits[0] = "grape";
println!("New first fruit: {}", fruits[0]);
#+END_SRC

#+RESULTS:
: New first fruit: grape


#+BEGIN_SRC rust  
 let mut fruits = vec!["apple", "banana"];
fruits.push("cherry");
println!("{:?}", fruits); // ["apple", "banana", "cherry"] 
#+END_SRC

#+RESULTS:
: ["apple", "banana", "cherry"]


#+BEGIN_SRC rust  
let mut fruits = vec!["apple", "banana", "cherry"];
fruits.pop();
println!("{:?}", fruits); // ["apple", "banana"] 
#+END_SRC

#+RESULTS:
: ["apple", "banana"]


#+BEGIN_SRC rust  
let mut fruits = vec!["banana", "orange"];
fruits.insert(0, "apple");
println!("{:?}", fruits); // ["apple", "banana", "orange"] 
#+END_SRC

#+RESULTS:
: ["apple", "banana", "orange"]


#+BEGIN_SRC rust  
let mut fruits = vec!["banana", "orange"];
fruits.insert(1, "apple");
println!("{:?}", fruits); // ["banana", "apple", "orange"] 
#+END_SRC

#+RESULTS:
: ["banana", "apple", "orange"]


#+BEGIN_SRC rust  
let mut fruits = vec!["apple", "banana", "orange"];
fruits.remove(0);
println!("{:?}", fruits); // ["banana", "orange"] 
#+END_SRC

#+RESULTS:
: ["banana", "orange"]


#+BEGIN_SRC rust  
let fruits = vec!["apple", "banana", "cherry"];
println!("There are {} fruits.", fruits.len());
#+END_SRC

#+RESULTS:
: There are 3 fruits.


#+BEGIN_SRC rust  
let fruits = vec!["apple", "banana", "orange"];
for fruit in &fruits {
  println!("I like {}.", fruit);
}
#+END_SRC

#+RESULTS:
: I like apple.
: I like banana.
: I like Orange.

* Tuples
#+BEGIN_SRC rust  
let person = ("John", 30, true);
println!("Name: {}", person.0);
println!("Age: {}", person.1);
println!("Is active: {}", person.2);
#+END_SRC

#+RESULTS:
: Name: John
: Age: 30
: Is active: true


#+BEGIN_SRC rust  
let person = ("Jenny", 45, false);
let (name, age, active) = person;

println!("Name: {}", name);
println!("Age: {}", age);
println!("Active: {}", active);
#+END_SRC

#+RESULTS:
: Name: Jenny
: Age: 45
: Active: false


#+BEGIN_SRC rust  
fn get_user() -> (String, i32) {
  (String::from("Liam"), 25)
}

fn main() {
  let user = get_user();
  println!("User: {} ({} years old)", user.0, user.1);
}
#+END_SRC

#+RESULTS:
: User: Liam (25 years old)


#+BEGIN_SRC rust  
// Import HashMap
use std::collections::HashMap;

fn main() {
  // Create a HashMap called capitalCities
  let mut capitalCities = HashMap::new();

  // Add keys and values (Country, City)
  capitalCities.insert("England", "London");
  capitalCities.insert("Germany", "Berlin");
  capitalCities.insert("Norway", "Oslo");

  println!("{:?}", capitalCities);
}
#+END_SRC

#+RESULTS:
: {"Norway": "Oslo", "England": "London", "Germany": "Berlin"}


#+BEGIN_SRC rust  
// Import HashMap
use std::collections::HashMap;

let mut capitalCities = HashMap::new();

capitalCities.insert("England", "London");
capitalCities.insert("Germany", "Berlin");
capitalCities.insert("Norway", "Oslo");

if let Some(city) = capitalCities.get("England") {
  println!("The capital of England is {}.", city);
} else {
  println!("England is not in the map.");
}
#+END_SRC

#+RESULTS:
: The capital of England is London.


#+BEGIN_SRC rust  
// Import HashMap
use std::collections::HashMap;

let mut capitalCities = HashMap::new();

capitalCities.insert("England", "London");
capitalCities.insert("England", "Berlin");

println!("{:?}", capitalCities);
#+END_SRC

#+RESULTS:
: {"England": "Berlin"}


#+BEGIN_SRC rust  
// Import HashMap
use std::collections::HashMap;

let mut capitalCities = HashMap::new();

// Add keys and values (Country, City)
capitalCities.insert("England", "London");
capitalCities.insert("Germany", "Berlin");
capitalCities.insert("Norway", "Oslo");

// Remove the key "England"
capitalCities.remove("England");

println!("{:?}", capitalCities);
#+END_SRC

#+RESULTS:
: {"Germany": "Berlin", "Norway": "Oslo"}


#+BEGIN_SRC rust  
// Import HashMap
use std::collections::HashMap;

let mut capitalCities = HashMap::new();

// Add keys and values (Country, City)
capitalCities.insert("England", "London");
capitalCities.insert("Germany", "Berlin");
capitalCities.insert("Norway", "Oslo");

// Loop through the HashMap
for (country, city) in &capitalCities {
  println!("The capital of {} is {}.", country, city);
}
#+END_SRC

#+RESULTS:
: The capital of Germany is Berlin.
: The capital of England is London.
: The capital of Norway is Oslo.

* Structs
#+BEGIN_SRC rust  
// Create a Struct called Person
struct Person {
  name: String,
  age: u32,
  can_vote: bool,
}

// Create a Person object
let user = Person {
  name: String::from("John"),
  age: 35,
  can_vote: true,
};

// Access and print the values
println!("Name: {}", user.name);
println!("Age: {}", user.age);
println!("Can vote? {}", user.can_vote);
#+END_SRC

#+RESULTS:
: Name: John
: Age: 35
: Can vote? true


#+BEGIN_SRC rust  
struct Person {
  name: String,
  age: u32,
}

let mut user = Person {
  name: String::from("John"),
  age: 35,
};

user.age = 36; // Change value of age
println!("Name: {}", user.name);
println!("Updated age: {}", user.age);
#+END_SRC

#+RESULTS:
: Name: John
: Updated age: 36

* Enums
#+BEGIN_SRC rust  
enum Direction {
  Up,
  Down,
  Left,
  Right,
}

fn main() {
  let my_direction = Direction::Up;
  println!("We are going up!");
}
#+END_SRC

#+RESULTS:
: We are going up!


#+BEGIN_SRC rust  
enum Direction {
  Up,
  Down,
  Left,
  Right,
}

fn main() {
  let my_direction = Direction::Left;

  match my_direction {
    Direction::Up => println!("Going up"),
    Direction::Down => println!("Going down"),
    Direction::Left => println!("Going left"),
    Direction::Right => println!("Going right"),
  }
}
#+END_SRC

#+RESULTS:
: Going left


#+BEGIN_SRC rust  
enum LoginStatus {
  Success(String),
  Error(String),
}

fn main() {
  let result1 = LoginStatus::Success(String::from("Welcome, John!"));
  let result2 = LoginStatus::Error(String::from("Incorrect password"));

  match result1 {
    LoginStatus::Success(message) => println!("Success: {}", message),
    LoginStatus::Error(message) => println!("Error: {}", message),
  }
}
#+END_SRC

#+RESULTS:
: Success: Welcome, John!

* Example with Tangling and LSP Support

This section demonstrates using ~:tangle~ to create actual Rust files that rust-analyzer can analyze.

** Basic Example with Library
#+BEGIN_SRC rust
use std::collections::HashMap;
use std::fs;
 
fn main() {
    // Create a HashMap with some data
    let mut scores = HashMap::new();
    scores.insert("Alice", 50);
    scores.insert("Bob", 30);

    // Print the scores
    for (name, score) in &scores {
        println!("{}: {}", name, score);
    }

    // Use std::fs to demonstrate library completion
    let path = "/tmp/test.txt";
    match fs::read_to_string(path) {
        Ok(contents) => println!("File contents: {}", contents),
        Err(e) => println!("Error reading file: {}", e),
    }
}
#+END_SRC

#+RESULTS:
: Alice: 50
: Bob: 30
: Error reading file: No such file or directory (os error 2)

** How to Use This:

1. *Tangle the code:* Run ~M-x org-babel-tangle~ (or ~C-c C-v t~) to create the file ~../org_examples/src/main.rs~
2. *Open the tangled file:* Open ~../org_examples/src/main.rs~ in Emacs
3. *Get full LSP support:* Now you have complete rust-analyzer support with:
   - Library completions (HashMap, fs, etc.)
   - Type inference
   - Error checking
   - Documentation on hover
   - Go to definition
4. *Workflow:*
   - Edit the tangled ~.rs~ file directly for complex code with LSP support
   - Keep the org file for documentation and simple examples
   - Run code with ~C-c C-v e~ in org blocks or ~cargo run -p org_examples~ in terminal
