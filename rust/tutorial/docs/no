#+STARTUP: content
* Intro
#+BEGIN_SRC rust
fn main(){
    println!("hello world");
}
#+END_SRC

#+RESULTS:
: hello World

* Variables
#+BEGIN_SRC rust  
let name = "John";
let age = 30;
println!("{} is {} years old.", name, age); 
#+END_SRC

#+RESULTS:
: John is 30 years old.


#+BEGIN_SRC rust  
let mut x = 5;
println!("Before: {}", x);
x = 10;
println!("After: {}", x); 
#+END_SRC

#+RESULTS:
: Before: 5
: After: 10
** Shadowing
#+BEGIN_SRC rust  
fn main() {
    let z = 5;  // Immutable variable
    let z = z + 1;  // Shadowing the previous variable
    println!("The value of z after shadowing is: {}", z);
    let z = "six";  // Shadowing with a different type
    println!("The value of z after shadowing with a different type is: {}", z);
}
#+END_SRC

#+RESULTS:
: The value of z after shadowing is: 6
: The value of z after shadowing with a different type is: Six

* Data Types
** Integers
#+BEGIN_SRC rust  
fn main() {
    let int_num: i32 = -42;         // 32-bit signed integer
    let uint_num: u64 = 123456;     // 64-bit unsigned integer
    println!("Signed Integer: {}", int_num);
    println!("Unsigned Integer: {}", uint_num);
}
#+END_SRC

#+RESULTS:
: Signed Integer: -42
: Unsigned Integer: 123456


#+BEGIN_SRC rust  
let age: i32 = 25;
println!("Age is: {}", age); 
#+END_SRC

#+RESULTS:
: Age is: 25

** Floating-Point Numbers
#+BEGIN_SRC rust  
let price: f64 = 19.99;
println!("Price is: ${}", price); 
#+END_SRC

#+RESULTS:
: Price is: $19.99

#+BEGIN_SRC rust
fn main() {
    let float_num: f64 = 3.14;      // 64-bit floating-point number
    println!("Floating-point: {}", float_num);
}
#+END_SRC

#+RESULTS:
: Floating-point: 3.14

** Characters
#+BEGIN_SRC rust  
let my_grade: char = 'B';
println!("{}", my_grade); 
#+END_SRC

#+RESULTS:
: B


#+BEGIN_SRC rust  
fn main() {
    let char_symbol: char = 'A';    // Unicode character
    println!("Character: {}", char_symbol);
}
#+END_SRC

#+RESULTS:
: Character: A

#+BEGIN_SRC rust  
let name: &str = "John";
println!("Hello, {}!", name); 
#+END_SRC

#+RESULTS:
: Hello, John!

** Booleans
#+BEGIN_SRC rust  
let is_logged_in: bool = true;
println!("User logged in? {}", is_logged_in); 
#+END_SRC

#+RESULTS:
: User logged in? True

#+BEGIN_SRC rust  
fn main() {
    let is_true: bool = true;       // Boolean (true/false)
    println!("Boolean: {}", is_true);
}
#+END_SRC

#+RESULTS:
: Boolean: true

* Constant
#+BEGIN_SRC rust  
fn main() {
    const BIRTHYEAR: i32 = 1980;
    const MINUTES_PER_HOUR: i32 = 60;
    const MAX_POINTS: u32 = 100_000;
    println!("The maximum points are: {}", MAX_POINTS);
}
#+END_SRC

#+RESULTS:
: The maximum points are: 100000

* Operators
#+BEGIN_SRC rust  
fn main() {
  let add = 5 + 3;
  let sub = 10 - 4;
  let mul = 6 * 2;
  let div = 12 / 3;
  let rem = 10 % 3;

  println!("Add: {}", add);
  println!("Sub: {}", sub);
  println!("Mul: {}", mul);
  println!("Div: {}", div);
  println!("Rem: {}", rem);
}
#+END_SRC

#+RESULTS:
: Add: 8
: Sub: 6
: Mul: 12
: Div: 4
: Rem: 1


#+BEGIN_SRC rust  
fn main() {
  let mut x = 10;
  println!("Start: {}", x);

  x += 5;
  println!("After += 5: {}", x);

  x -= 2;
  println!("After -= 2: {}", x);

  x *= 2;
  println!("After *= 2: {}", x);

  x /= 3;
  println!("After /= 3: {}", x);

  x %= 4;
  println!("After %= 4: {}", x);
}
#+END_SRC

#+RESULTS:
: Start: 10
: After += 5: 15
: After -= 2: 13
: After *= 2: 26
: After /= 3: 8
: After %= 4: 0

* Booleans
#+BEGIN_SRC rust  
fn main() {
  let a = 5;
  let b = 10;

  println!("5 == 10: {}", a == b);
  println!("5 != 10: {}", a != b);
  println!("5 < 10: {}", a < b);
  println!("5 >= 10: {}", a >= b);
}
#+END_SRC

#+RESULTS:
: 5 == 10: false
: 5 != 10: true
: 5 < 10: true
: 5 >= 10: false


#+BEGIN_SRC rust  
fn main() {
  let logged_in = true;
  let is_admin = false;

  println!("Is regular user: {}", logged_in && !is_admin);
  println!("Has any access: {}", logged_in || is_admin);
  println!("Not logged in: {}", !logged_in);
}
#+END_SRC

#+RESULTS:
: Is regular user: true
: Has any access: true
: Not logged in: false


#+BEGIN_SRC rust  
let is_programming_fun: bool = true;
let is_fish_tasty: bool = false;

println!("Is Programming Fun? {}", is_programming_fun);
println!("Is Fish Tasty? {}", is_fish_tasty);
#+END_SRC

#+RESULTS:
: Is Programming Fun? true
: Is Fish Tasty? false


#+BEGIN_SRC rust  
let is_programming_fun = true;
let is_fish_tasty = false;

println!("Is Programming Fun? {}", is_programming_fun);
println!("Is Fish Tasty? {}", is_fish_tasty);
#+END_SRC

#+RESULTS:
: Is Programming Fun? true
: Is Fish Tasty? false


#+BEGIN_SRC rust  
let age = 20;
let can_vote = age >= 18;

println!("Can vote? {}", can_vote); 
#+END_SRC

#+RESULTS:
: Can vote? true


#+BEGIN_SRC rust  
let is_logged_in = true;

if is_logged_in {
  println!("Welcome back!");
} else {
  println!("Please log in.");
}
#+END_SRC

#+RESULTS:
: Welcome Back!

* Conditions
#+BEGIN_SRC rust  
let x = 7;
let y = 5;

if x > y {
  println!("x is greater than y.");
} 
#+END_SRC

#+RESULTS:
: x is greater than y.


#+BEGIN_SRC rust  
let age = 16;

if age >= 18 {
  println!("You can vote.");
} else {
  println!("You are too young to vote.");
} 
#+END_SRC

#+RESULTS:
: You are too young to vote.


#+BEGIN_SRC rust  
let score = 85;

if score >= 90 {
  println!("Grade: A");
} else if score >= 80 {
  println!("Grade: B");
} else if score >= 70 {
  println!("Grade: C");
} else {
  println!("Grade: F");
}
#+END_SRC

#+RESULTS:
: Grade: B


#+BEGIN_SRC rust  
let time = 20;
let greeting = if time < 18 {
  "Good day."
} else {
  "Good evening."
};
println!("{}", greeting);
#+END_SRC

#+RESULTS:
: Good evening.


#+BEGIN_SRC rust  
let number = 5;
let result = if number < 10 { "Too small" } else { 100 };
println!("{}", result);
#+END_SRC

#+Results:

* Match
#+BEGIN_SRC rust  
fn main() {
    let day = 4;

    match day {
	1 => println!("Monday"),
	2 => println!("Tuesday"),
	3 => println!("Wednesday"),
	4 => println!("Thursday"),
	5 => println!("Friday"),
	6 => println!("Saturday"),
	7 => println!("Sunday"),
	_ => println!("Invalid day."),
    }
}
#+END_SRC

#+RESULTS:
: Thursday


#+BEGIN_SRC rust  
fn main() {
  let day = 6;

  match day {
    1 | 2 | 3 | 4 | 5 => println!("Weekday"),
    6 | 7 => println!("Weekend"),
    _ => println!("Invalid day"),
  }
}
#+END_SRC

#+RESULTS:
: Weekend


#+BEGIN_SRC rust  
fn main() {
  let day = 4;

  let result = match day {
    1 => "Monday",
    2 => "Tuesday",
    3 => "Wednesday",
    4 => "Thursday",
    5 => "Friday",
    6 => "Saturday",
    7 => "Sunday",
    _ => "Invalid day.",
  };

  println!("{}", result);
} 
#+END_SRC

#+RESULTS:
: Thursday

* Loops
#+BEGIN_SRC rust  
let mut count = 1;

loop {
  println!("Hello World!");

  if count == 3 {
    break;
  }

  count += 1;
} 
#+END_SRC

#+RESULTS:
: Hello World!
: Hello World!
: Hello World!


#+BEGIN_SRC rust  
let mut count = 1;

let result = loop {
  println!("Hello!");

  if count == 3 {
    break count; // Stop the loop and return the number 3
  }

  count += 1;
};

println!("The loop stopped at: {}", result); 
#+END_SRC

#+RESULTS:
: Hello!
: Hello!
: Hello!
: The loop stopped at: 3

* While Loops
#+BEGIN_SRC rust  
let mut count = 1;

while count <= 5 {
  println!("Count: {}", count);
  count += 1;
}
#+END_SRC

#+RESULTS:
: Count: 1
: Count: 2
: Count: 3
: Count: 4
: Count: 5


#+BEGIN_SRC rust  
let mut num = 1;

while num <= 10 {
  if num == 6 {
    break;
  }
  println!("Number: {}", num);
  num += 1;
}
#+END_SRC

#+RESULTS:
: Number: 1
: Number: 2
: Number: 3
: Number: 4
: Number: 5


#+BEGIN_SRC rust  
let mut num = 1;

while num <= 10 {
  if num == 6 {
    num += 1;
    continue;
  }

  println!("Number: {}", num);
  num += 1;
}
#+END_SRC

#+RESULTS:
: Number: 1
: Number: 2
: Number: 3
: Number: 4
: Number: 5
: Number: 7
: Number: 8
: Number: 9
: Number: 10

* For Loops
#+BEGIN_SRC rust  
for i in 1..6 {
  println!("i is: {}", i);
}
#+END_SRC

#+RESULTS:
: i is: 1
: i is: 2
: i is: 3
: i is: 4
: i is: 5


#+BEGIN_SRC rust  
for i in 1..=6 {
  println!("i is: {}", i);
}
#+END_SRC

#+RESULTS:
: i is: 1
: i is: 2
: i is: 3
: i is: 4
: i is: 5
: i is: 6


#+BEGIN_SRC rust  
for i in 1..=10 {
  if i == 3 {
    continue; // skip 3
  }
  if i == 5 {
    break; // stop before printing 5
  }
  println!("i is: {}", i);
}
#+END_SRC

#+RESULTS:
: i is: 1
: i is: 2
: i is: 4

* Functions
#+BEGIN_SRC rust  
// Create a function
fn say_hello() {
  println!("Hello from a function!");
}

say_hello(); // Call the function 
#+END_SRC

#+RESULTS:
: Hello from a function!


#+BEGIN_SRC rust  
fn greet(name: &str) {
  println!("Hello, {}!", name);
}

greet("John");
#+END_SRC

#+RESULTS:
: Hello, John!


#+BEGIN_SRC rust  
fn add(a: i32, b: i32) -> i32 {
  return a + b;
}

let sum = add(3, 4);
println!("Sum is: {}", sum);
#+END_SRC

#+RESULTS:
: Sum is: 7


#+BEGIN_SRC rust  
fn add(a: i32, b: i32) -> i32 {
  a + b  // omit return
}

let sum = add(3, 4);
println!("Sum is: {}", sum);
#+END_SRC

#+RESULTS:
: Sum is: 7

#+BEGIN_SRC rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
#+END_SRC

#+RESULTS:
: Hello, world!
: Another function.


#+BEGIN_SRC rust  
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {x}");
}
#+END_SRC

#+RESULTS:
: The value of x is: 5


#+BEGIN_SRC rust  

#+END_SRC

* Scope
#+BEGIN_SRC rust  
let x = 5;

{
  let x = 10;
  println!("Inside block: {}", x);
}

println!("Outside block: {}", x);
#+END_SRC

#+RESULTS:
: Inside block: 10
: Outside block: 5

* Strings
#+BEGIN_SRC rust  
let greeting: &str = "Hello";
println!("{}", greeting); 
#+END_SRC

#+RESULTS:
: Hello


#+BEGIN_SRC rust  
let text1 = "Hello World".to_string();
println!("{}", text1)
#+END_SRC

#+RESULTS:
: Hello World


#+BEGIN_SRC rust  
let text2 = String::from("Hello World");
println!("{}", text2)
#+END_SRC

#+RESULTS:
: Hello World


#+BEGIN_SRC rust  
let mut greeting = String::from("Hello");
greeting.push_str(" World");
println!("{}", greeting); // Hello World 
#+END_SRC

#+RESULTS:
: Hello World


#+BEGIN_SRC rust  
 let mut word = String::from("Hi");
word.push('!');
println!("{}", word); // Hi!
#+END_SRC

#+RESULTS:
: Hi!


#+BEGIN_SRC rust  
let s1 = String::from("Hello");
let s2 = String::from("World!");
let s3 = String::from("What a beautiful day!");
let result = format!("{} {} {}", s1, s2, s3);
println!("{}", result);
#+END_SRC

#+RESULTS:
: Hello World! What a beautiful day!


#+BEGIN_SRC rust  
let s1 = String::from("Hello");
let s2 = String::from("World!");
let s3 = String::from("What a beautiful day!");
let result = s1 + " " + &s2 + " " + &s3;
println!("{}", result);
#+END_SRC

#+RESULTS:
: Hello World! What a beautiful day!


#+BEGIN_SRC rust  
let name = String::from("John");
println!("Length: {}", name.len()); // 4 
#+END_SRC

#+RESULTS:
: Length: 4

* Ownership
#+BEGIN_SRC rust  
let a = String::from("Hello");
let b = a;

// println!("{}", a); Error: a no longer owns the value
println!("{}", b); // Ok: b now owns the value 
#+END_SRC

#+RESULTS:
: Hello


#+BEGIN_SRC rust  
let a = 5;
let b = a;
println!("a = {}", a);  // Works
println!("b = {}", b);  // Works 
#+END_SRC

#+RESULTS:
: a = 5
: b = 5


#+BEGIN_SRC rust  
let a = String::from("Hello");
let b = a.clone(); // Now both have the same value

println!("a = {}", a);  // Works
println!("b = {}", b);  // Works 
#+END_SRC

#+RESULTS:
: a = Hello
: b = Hello

* Borrowing and References
#+BEGIN_SRC rust  
let a = String::from("Hello");
let b = &a;

println!("a = {}", a);
println!("b = {}", b); 
#+END_SRC

#+RESULTS:
: a = Hello
: b = Hello


#+BEGIN_SRC rust  
let mut name = String::from("John");
let name_ref = &mut name;
name_ref.push_str(" Doe");

println!("{}", name_ref); // John Doe 
#+END_SRC

#+RESULTS:
: John Doe

* Data Structures
** Arrays
#+BEGIN_SRC rust  
let fruits = ["apple", "banana", "orange"];
println!("Last fruit: {}", fruits[2]); 
#+END_SRC

#+RESULTS:
: Last fruit: Orange

#+BEGIN_SRC rust  
let numbers = [1, 2, 3, 4, 5];
println!("The first number is: {}", numbers[0]);
#+END_SRC

#+RESULTS:
: The first number is: 1


#+BEGIN_SRC rust  
let mut numbers = [1, 2, 3, 4, 5];
numbers[0] = 10;
println!("The new first number is: {}", numbers[0]);
#+END_SRC

#+RESULTS:
: The new first number is: 10


#+BEGIN_SRC rust  
let numbers = [1, 2, 3, 4, 5];
println!("This array has {} elements.", numbers.len());
#+END_SRC

#+RESULTS:
: This array has 5 elements.


#+BEGIN_SRC rust  
let fruits = ["apple", "banana", "orange"];
for fruit in fruits {
  println!("I like {}.", fruit);
}
#+END_SRC

#+RESULTS:
: I like apple.
: I like banana.
: I like orange.


#+BEGIN_SRC rust  
let numbers = [1, 2, 3, 4, 5];
println!("{:?}", numbers); 
#+END_SRC

#+RESULTS:
: [1, 2, 3, 4, 5]


#+BEGIN_SRC rust  
let numbers = [1, 2, 3, 4, 5];
println!("{}", numbers[0]);
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
println!("{:?}", a);
#+END_SRC

#+RESULTS:
: [1, 2, 3, 4, 5]

#+BEGIN_SRC rust
let a = [3; 5];
println!("{:?}", a)
#+END_SRC

#+RESULTS:
: [3, 3, 3, 3, 3]

** Vectors
#+BEGIN_SRC rust  
let mut fruits = vec!["apple", "banana"];
fruits.push("cherry");

println!("Last fruit: {}", fruits[2]); 
#+END_SRC

#+RESULTS:
: Last fruit: Cherry

#+BEGIN_SRC rust  
// A vector with 3 elements
let mut cars = vec!["Volvo", "BMW", "Ford"];

// Add another element
cars.push("Mazda");

println!("{:?}", cars); // ["Volvo", "BMW", "Ford", "Mazda"] 
#+END_SRC

#+RESULTS:
: ["Volvo", "BMW", "Ford", "Mazda"]


#+BEGIN_SRC rust  
let fruits = vec!["apple", "banana", "orange"];
println!("First fruit: {}", fruits[0]);
#+END_SRC

#+RESULTS:
: First fruit: apple


#+BEGIN_SRC rust  
let mut fruits = vec!["apple", "banana", "orange"];
fruits[0] = "grape";
println!("New first fruit: {}", fruits[0]);
#+END_SRC

#+RESULTS:
: New first fruit: grape


#+BEGIN_SRC rust  
 let mut fruits = vec!["apple", "banana"];
fruits.push("cherry");
println!("{:?}", fruits); // ["apple", "banana", "cherry"] 
#+END_SRC

#+RESULTS:
: ["apple", "banana", "cherry"]


#+BEGIN_SRC rust  
let mut fruits = vec!["apple", "banana", "cherry"];
fruits.pop();
println!("{:?}", fruits); // ["apple", "banana"] 
#+END_SRC

#+RESULTS:
: ["apple", "banana"]


#+BEGIN_SRC rust  
let mut fruits = vec!["banana", "orange"];
fruits.insert(0, "apple");
println!("{:?}", fruits); // ["apple", "banana", "orange"] 
#+END_SRC

#+RESULTS:
: ["apple", "banana", "orange"]


#+BEGIN_SRC rust  
let mut fruits = vec!["banana", "orange"];
fruits.insert(1, "apple");
println!("{:?}", fruits); // ["banana", "apple", "orange"] 
#+END_SRC

#+RESULTS:
: ["banana", "apple", "orange"]


#+BEGIN_SRC rust  
let mut fruits = vec!["apple", "banana", "orange"];
fruits.remove(0);
println!("{:?}", fruits); // ["banana", "orange"] 
#+END_SRC

#+RESULTS:
: ["banana", "orange"]


#+BEGIN_SRC rust  
let fruits = vec!["apple", "banana", "cherry"];
println!("There are {} fruits.", fruits.len());
#+END_SRC

#+RESULTS:
: There are 3 fruits.


#+BEGIN_SRC rust  
let fruits = vec!["apple", "banana", "orange"];
for fruit in &fruits {
  println!("I like {}.", fruit);
}
#+END_SRC

#+RESULTS:
: I like apple.
: I like banana.
: I like Orange.

** Tuples
#+BEGIN_SRC rust  
let person = ("John", 30, true);
println!("Name: {}", person.0);
println!("Age: {}", person.1);
println!("Is active: {}", person.2); 
#+END_SRC

#+RESULTS:
: Name: John
: Age: 30
: Is active: True

#+BEGIN_SRC rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}
#+END_SRC

#+RESULTS:
: The value of y is: 6.4


#+BEGIN_SRC rust  
let person = ("John", 30, true);
println!("Name: {}", person.0);
println!("Age: {}", person.1);
println!("Is active: {}", person.2);
#+END_SRC

#+RESULTS:
: Name: John
: Age: 30
: Is active: true


#+BEGIN_SRC rust  
let person = ("Jenny", 45, false);
let (name, age, active) = person;

println!("Name: {}", name);
println!("Age: {}", age);
println!("Active: {}", active);
#+END_SRC

#+RESULTS:
: Name: Jenny
: Age: 45
: Active: false


#+BEGIN_SRC rust  
fn get_user() -> (String, i32) {
  (String::from("Liam"), 25)
}

fn main() {
  let user = get_user();
  println!("User: {} ({} years old)", user.0, user.1);
}
#+END_SRC

#+RESULTS:
: User: Liam (25 years old)


#+BEGIN_SRC rust  
// Import HashMap
use std::collections::HashMap;

fn main() {
  // Create a HashMap called capitalCities
  let mut capitalCities = HashMap::new();

  // Add keys and values (Country, City)
  capitalCities.insert("England", "London");
  capitalCities.insert("Germany", "Berlin");
  capitalCities.insert("Norway", "Oslo");

  println!("{:?}", capitalCities);
}
#+END_SRC

#+RESULTS:
: {"Norway": "Oslo", "England": "London", "Germany": "Berlin"}


#+BEGIN_SRC rust  
// Import HashMap
use std::collections::HashMap;

let mut capitalCities = HashMap::new();

capitalCities.insert("England", "London");
capitalCities.insert("Germany", "Berlin");
capitalCities.insert("Norway", "Oslo");

if let Some(city) = capitalCities.get("England") {
  println!("The capital of England is {}.", city);
} else {
  println!("England is not in the map.");
}
#+END_SRC

#+RESULTS:
: The capital of England is London.


#+BEGIN_SRC rust  
// Import HashMap
use std::collections::HashMap;

let mut capitalCities = HashMap::new();

capitalCities.insert("England", "London");
capitalCities.insert("England", "Berlin");

println!("{:?}", capitalCities);
#+END_SRC

#+RESULTS:
: {"England": "Berlin"}


#+BEGIN_SRC rust  
// Import HashMap
use std::collections::HashMap;

let mut capitalCities = HashMap::new();

// Add keys and values (Country, City)
capitalCities.insert("England", "London");
capitalCities.insert("Germany", "Berlin");
capitalCities.insert("Norway", "Oslo");

// Remove the key "England"
capitalCities.remove("England");

println!("{:?}", capitalCities);
#+END_SRC

#+RESULTS:
: {"Germany": "Berlin", "Norway": "Oslo"}


#+BEGIN_SRC rust  
// Import HashMap
use std::collections::HashMap;

let mut capitalCities = HashMap::new();

// Add keys and values (Country, City)
capitalCities.insert("England", "London");
capitalCities.insert("Germany", "Berlin");
capitalCities.insert("Norway", "Oslo");

// Loop through the HashMap
for (country, city) in &capitalCities {
  println!("The capital of {} is {}.", country, city);
}
#+END_SRC

#+RESULTS:
: The capital of Germany is Berlin.
: The capital of England is London.
: The capital of Norway is Oslo.

** HashMaps
#+BEGIN_SRC rust  
// Import HashMap
use std::collections::HashMap;

fn main() {
  let mut capital_cities = HashMap::new();
  capital_cities.insert("France", "Paris");
  capital_cities.insert("Japan", "Tokyo");

  println!("Capital of Japan is {}", capital_cities["Japan"]);
}
#+END_SRC

#+RESULTS:
: Capital of Japan is Tokyo

* Structs
#+BEGIN_SRC rust  
// Create a Struct called Person
struct Person {
  name: String,
  age: u32,
  can_vote: bool,
}

// Create a Person object
let user = Person {
  name: String::from("John"),
  age: 35,
  can_vote: true,
};

// Access and print the values
println!("Name: {}", user.name);
println!("Age: {}", user.age);
println!("Can vote? {}", user.can_vote);
#+END_SRC

#+RESULTS:
: Name: John
: Age: 35
: Can vote? true


#+BEGIN_SRC rust  
struct Person {
  name: String,
  age: u32,
}

let mut user = Person {
  name: String::from("John"),
  age: 35,
};

user.age = 36; // Change value of age
println!("Name: {}", user.name);
println!("Updated age: {}", user.age);
#+END_SRC

#+RESULTS:
: Name: John
: Updated age: 36

* Enums
#+BEGIN_SRC rust  
enum Direction {
  Up,
  Down,
  Left,
  Right,
}

fn main() {
  let my_direction = Direction::Up;
  println!("We are going up!");
}
#+END_SRC

#+RESULTS:
: We are going up!


#+BEGIN_SRC rust  
enum Direction {
  Up,
  Down,
  Left,
  Right,
}

fn main() {
  let my_direction = Direction::Left;

  match my_direction {
    Direction::Up => println!("Going up"),
    Direction::Down => println!("Going down"),
    Direction::Left => println!("Going left"),
    Direction::Right => println!("Going right"),
  }
}
#+END_SRC

#+RESULTS:
: Going left


#+BEGIN_SRC rust  
enum LoginStatus {
  Success(String),
  Error(String),
}

fn main() {
  let result1 = LoginStatus::Success(String::from("Welcome, John!"));
  let result2 = LoginStatus::Error(String::from("Incorrect password"));

  match result1 {
    LoginStatus::Success(message) => println!("Success: {}", message),
    LoginStatus::Error(message) => println!("Error: {}", message),
  }
}
#+END_SRC

#+RESULTS:
: Success: Welcome, John!

* Control Flow
#+BEGIN_SRC rust
fn main() {
    // Function definition
    fn greet(name: &str) {
        println!("Hello, {}!", name);
    }
    // Function invocation
    greet("Alice");
    greet("Bob");
    // Another function example
    fn add(a: i32, b: i32) -> i32 {
        a + b
    }
    let sum = add(5, 7);
    println!("The sum is: {}", sum);
}
#+END_Src

#+RESULTS:
: Hello, Alice!
: Hello, Bob!
: The sum is: 12

* Data Types and Structures
** Scalar Types
** Compound Types
** Structs
#+BEGIN_SRC rust  
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
        active: true,
    };
    println!("Username: {}", user1.username);
    println!("Email: {}", user1.email);
    println!("Sign in count: {}", user1.sign_in_count);
    println!("Active: {}", user1.active);
}
#+END_Src

#+RESULTS:
: Username: someusername123
: Email: someone@example.com
: Sign in count: 1
: Active: true

#+BEGIN_SRC rust  
struct Color(i32, i32, i32);
fn main() {
    let black = Color(0, 0, 0);
    println!("Black: ({}, {}, {})", black.0, black.1, black.2);
}
#+END_SRC

#+RESULTS:
: Black: (0, 0, 0)


#+BEGIN_SRC rust  
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
fn main() {
    let user1 = User {
        username: String::from("user1"),
        email: String::from("user1@example.com"),
        sign_in_count: 1,
        active: true,
    };
    let user2 = User {
        email: String::from("user2@example.com"),
        ..user1 // Copies the remaining fields from user1
    };
    println!("Username: {}", user2.username);
    println!("Email: {}", user2.email);
    println!("Sign in count: {}", user2.sign_in_count);
    println!("Active: {}", user2.active);
}
#+END_SRC

#+RESULTS:
: Username: user1
: Email: user2@example.com
: Sign in count: 1
: Active: True

* Methods and Associated Functions
#+BEGIN_SRC rust  
struct Rectangle {
    width: u32,
    height: u32,
}
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };
    println!("The area of rect1 is {} square pixels.", rect1.area());
    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
#+END_SRC

#+RESULTS:
: The area of rect1 is 1500 square pixels.
: Can rect1 hold rect2? true
: Can rect1 hold rect3? false


#+BEGIN_SRC rust  
struct Rectangle {
    width: u32,
    height: u32,
}
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
    // A method (takes &self)
    fn area(&self) -> u32 {
        self.width * self.height
    }
}
fn main() {
    let sq = Rectangle::square(3);
    println!("The area of the square is {} square pixels.", sq.area());
}
#+END_SRC

#+RESULTS:
: The area of the square is 9 square pixels.

* Statements and Expressions
- Statements :: instructions that perform some action and do not return a value.
- Expressions :: evaluate to a resultant value, eg: calling a function or macro.
- Brackets :: A new scope block created with curly brackets is an expression
- Expressions do not include ending semicolons. If you add a semicolon to the end of an expression, you turn it into a statement, and it will then not return a value.
#+BEGIN_SRC rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {y}");
}
#+END_SRC

#+RESULTS:
: The value of y is: 4


#+BEGIN_SRC rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {x}");
}
#+END_SRC

#+RESULTS:
: The value of x is: 5


#+BEGIN_SRC rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
#+END_SRC

#+RESULTS:
: The value of x is: 6

* Control Flow
** If Expressions
#+BEGIN_SRC rust  
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
#+END_SRC

#+RESULTS:
: condition was true

#+BEGIN_SRC rust  
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
#+END_SRC

#+RESULTS:
: number is divisible by 3

#+BEGIN_SRC rust  
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}
#+END_SRC

#+RESULTS:
: The value of number is: 5

** Repetition with Loops
#+BEGIN_SRC rust 
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {result}");
}
#+END_SRC

#+RESULTS:
: The result is 20


#+BEGIN_SRC rust  
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
#+END_SRC

#+RESULTS:
: count = 0
: remaining = 10
: remaining = 9
: count = 1
: remaining = 10
: remaining = 9
: count = 2
: remaining = 10
: End count = 2

** Streamlining Conditional Loops with while
#+BEGIN_SRC rust  
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
#+END_SRC

#+RESULTS:
: 3!
: 2!
: 1!
: LIFTOFF!!!

** Looping Through a Collection with for
#+BEGIN_SRC rust  
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
#+END_SRC

#+RESULTS:
: the value is: 10
: the value is: 20
: the value is: 30
: the value is: 40
: the value is: 50

** Reverse the range
#+BEGIN_SRC rust  
fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
#+END_SRC

#+RESULTS:
: 3!
: 2!
: 1!
: LIFTOFF!!!

* Understanding Ownership
- Memory is managed through a system of ownership with a set of rules that the compiler checks. If any of the rules are violated, the program won’t compile.
- None of the features of ownership will slow down your program while it’s running.
** The Stack and the Heap
- Stack :: stores values in the order it gets them and removes the values in the opposite order. This is referred to as last in, first out (LIFO). 
- Adding data is called /pushing onto the stack/, and removing data is called /popping off the stack/.
- Heap :: When you put data on the heap, you request a certain amount of space. The memory allocator finds an empty spot in the heap that is big enough, marks it as being in use, and returns a pointer, which is the address of that location. This process is called /allocating on the heap/ and is sometimes abbreviated as just /allocating/.
- Pushing to the stack is faster than allocating on the heap because the allocator never has to search for a place to store new data; that location is always at the top of the stack. Comparatively, allocating space on the heap requires more work because the allocator must first find a big enough space to hold the data and then perform bookkeeping to prepare for the next allocation.
- When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function’s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.
** Ownership Rules
- Each value in Rust has an owner.
- There can only be one owner at a time.
- When the owner goes out of scope, the value will be dropped.

#+BEGIN_SRC rust
fn main(){
    
}
#+END_SRC
