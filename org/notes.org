#+PROPERTY: header-args:python :python "nix-shell ~/shell.nix --pure --run python" :results output
#+PROPERTY: header-args:shell :shebang "#!/usr/bin/env nix-shell\n#!nix-shell /tmp/shell.nix -i bash --pure"
#+PROPERTY: header-args:nix :strict t
# #+PROPERTY: header-args:jupyter-python :session /jpy:localhost#7777?token=mytoken
# #+PROPERTY: header-args:jupyter-python :session
# /jpy::thermo:7777?token=mytoken

* Software Development
- cp /var/lib/snapd/desktop/applications/remmina_remmina.desktop ~/.local/share/applications/
** TODO Regular Expression
- Sed and Awk
** TODO Orgmode
** TODO Database
- Postgresql
- Sqlite3
** TODO Image Analysis
- scikit-image
** TODO Design of Experiment
- R
** Convert ipynb to org file
#+BEGIN_SRC sh
# convert all: ipynb file --> org files
find ./ -iname "*.ipynb" -type f -exec sh -c 'pandoc "${0}" -o "${0%.ipynb}.org"' {} \;

# replace "python" with "jupyter-python" recursively
find . -type f -name "*.org" -exec sed -i 's/python/jupyter-python/g' {} +
#+END_SRC

#+NAME: jupytext
#+BEGIN_SRC sh :results output :var input="input.md"
jupytext --to md $input 
#+END_SRC

#+CALL: jupytext(input="my_markdown_file.md")

#+NAME: pandoc
#+BEGIN_SRC sh :results output :var input="input.md" output="output.pdf"
pandoc $input -o $output
#+END_SRC

#+CALL: pandoc(input="my_markdown_file.md", output="my_converted_file.pdf")

** Using a Code Block as a Function
#+name: square
#+header: :var x=0
#+begin_src python
return x*x
#+end_src
#+call: square(x=6)

#+RESULTS:
: 36

* Jupyter BOOK
#+begin_src sh
conda install gh --channel conda-forge

gh auth login

sudo dpkg -i gcm-linux_amd64.2.3.2.deb

git-credential-manager configure

git config --global credential.credentialStore cache

git clone https://github.com/dragonleopardpig/myonlinebook

jupyter-book clean mylocalbook/ --all

jupyter-book build mylocalbook/ --all

rsync -avP --delete --cvs-exclude mylocalbook/ myonlinebook/

cd myonlinebook

git add .

git commit -m "message"

git push

ghp-import -n -p -f _build/html -c optics.engineering
#+end_src

* Git
** Initialization
#+begin_src sh
git --version
git config --global user.name "dragonleopardpig"
git config --global user.email "dragonleopardpig@gmail.com"
mkdir myproject
cd myproject
git init 
#+end_src
** Checkout a repository
#+begin_src sh
git clone /path/to/repository
git clone username@host:/path/to/repository
#+end_src
** Workflow
- Working Directory -add-> Index(stage) -commit-> Head
** Add & Commit & Undo
#+begin_src sh :results output
git add <filename>
git add *
git add .
git add --all (or git add -A)
git add -i #interactive adding
git status --short # Lists all new or modified files to be committed
git commit -m "Commit message"
git commit -a -m "Updated index.html with a new line" #Skipping staging
git commit -help
git reset HEAD~1 # Remove the most recent commit. Commit again!
#+end_src
** Pushing Changes
#+begin_src sh :results output
git remote add origin <server> #if have not cloned
git push origin master # pushes changes to origin
git remote -v # List the remote connections you have to other repositories.
#+end_src
** Branching
#+begin_src sh :results output
git branch hello-world-images #created a new branch called "hello-world-images"
git branch #confirm that we have created a new branch
git checkout hello-world-images
git checkout -b feature_x #new branch called feature_x
git checkout master #switch back to master
git branch -d feature_x #delete branch feature_x
git push origin <branch>
#+end_src
** Update & Merge
#+begin_src sh :results output
git pull #update local repository to latest commit
git fetch #gathers any commits from the target branch that do not exist in your current branch and stores them in your local repository. However, it does not merge them with your current branch. git fetch followed by a git merge equals a git pull

git merge <branch> #to merge another branch into your active branch (e.g. master)
: 'git tries to auto-merge changes. Unfortunately, this is not always possible and results in conflicts. You are responsible to merge those conflicts manually by editing the files shown by git
'
git add <filename> #after changing mark them as merged
git diff # To show the files changes not yet staged
git diff <source_branch> <target_branch> #preview changes
#+end_src
** Tagging
#+begin_src sh :results output
git tag 1.0.0 1b2e1d63ff #tag named 1.0,0, 1b2e1d63ff stands for the first 10 characters of the commit id you want to reference with your tag
#+end_src
** Log
#+begin_src sh :results output
git log --author=bob #see commit from author bob
git log --pretty=oneline
git log --graph --oneline --decorate --all
git log --name-status #see only which files have changed
git log --help
git log origin/master
#+end_src
** Replace local changes
#+begin_src sh :results output
git checkout .
git checkout -- <filename> #replace local changes for a specific file
git fetch origin #drop all local changes
git reset --hard origin/master
#+end_src
** Gitignore
#+begin_src sh :results output
touch .gitignore

: ' .gitignore file looks something like this:
/*.cmake
/*.DS_Store
/.user
/build
etc. depending upon the files you want git to untrack
'	       
#+end_src
* Cryfs and Restic
#+begin_src sh :results output
cryfs -c cryfs.config basedir mountdir
cryfs-unmount mountdir
restic init --repo /home/plchu/pCloudDrive/mountdir
restic -r /home/plchu/pCloudDrive/mountdir --verbose backup /home/plchu/mountdir/ -p /home/plchu/mountdir/.restic
restic -r /home/plchu/pCloudDrive/mountdir snapshots -p /home/plchu/mountdir/.restic

systemctl status cron
crontab -e
# add into the file for every minute restic backup
# * * * * * restic -r /home/plchu/pCloudDrive/mountdir backup /home/plchu/mountdir/ -p /home/plchu/mountdir/.restic

#+end_src
* R Babel
** produce a file, by using :results output
#+begin_src R :file 3.svg :results output graphics file
library(lattice)
xyplot(1:10 ~ 1:10)
#+end_src

** produce a file, by printing object
#+begin_src R :file 2.png :results graphics file
library(lattice)
print(xyplot(1:10 ~ 1:10))
#+end_src

** produce a file, by evaluating in :session
#+begin_src R :file 4.png :session :results graphics file
library(lattice)
xyplot(1:10 ~ 1:10)
#+end_src

* Encryption :crypt:
-----BEGIN PGP MESSAGE-----

jA0ECQMKdmtCbbEcitP80mMBFNzSGWBj9oNWpLPyeQv0NgdRoTfTaxx1DEYkBxzn
fCLSTmLXfGUKi7Vz/Cic0SV7bJke+6p3Q88uUvAHDkl3M11XVBi15qZb041Zm4zu
nXVKd1cWzhCs9Dow+bsfSTBHReI=
=uHRH
-----END PGP MESSAGE-----

* Sympy
#+begin_src python :python "nix-shell /tmp/shell.nix --pure --run python" :results output
from sympy import *
from IPython.display import display
init_printing()
x, y, z = symbols('x y z')

display(Integral(sqrt(1 / x), x))
#+END_SRC

#+RESULTS:
: Integral(sqrt(1/x), x)

* Jupyter Python
** Arbitrary Arguments, *args
#+BEGIN_SRC jupyter-python
def my_function(*kids):
  print("The youngest child is " + kids[2])

my_function("Emil", "Tobias", "Linus") 
#+END_SRC

#+RESULTS:
:RESULTS:
The youngest child is Linus
:END:

** Keyword Arguments
#+BEGIN_SRC python
def my_function(child3, child2, child1):
  print("The youngest child is " + child3)

my_function(child1 = "Emil", child2 = "Tobias", child3 = "Linus") 
#+END_SRC
#+RESULTS:
:RESULTS:
The youngest child is Linus
:END:
** Keyword Arguments, **kwargs
#+BEGIN_SRC python
def my_function(**kid):
  print("His last name is " + kid["lname"])

my_function(fname = "Tobias", lname = "Refsnes") 
#+END_SRC

#+RESULTS:
:RESULTS:
His last name is Refsnes
:END:

** Recursion
- Recursion :: a defined function can call itself. 
- It means that a function calls itself. This has the benefit of meaning that you can loop through data to reach a result.
#+BEGIN_SRC python
def tri_recursion(k):
  if(k > 0):
    result = k + tri_recursion(k - 1)
    print(result)
  else:
    result = 0
  return result

print("Recursion Example Results")
tri_recursion(6)
#+END_SRC

#+RESULTS:
:RESULTS:
Recursion Example Results
1
3
6
10
15
21
21
:END:

** Lambda Function
- lambda function :: a small anonymous function.
- Super() :: make the child class inherit all the methods and properties from its parent.
#+BEGIN_SRC python
def myfunc(n):
  return lambda a : a * n

mydoubler = myfunc(2)
mytripler = myfunc(3)

print(mydoubler(11))
print(mytripler(11))
#+END_SRC

#+RESULTS:
:RESULTS:
22
33
:END:

** Inheritance
- Inheritance :: define a class that inherits all the methods and properties from another class.
- Syntax :: lambda /arguments/ : /expression/
- A lambda function can take any number of arguments, but can only have one expression.
- The power of lambda is better shown when you use them as an anonymous function inside another function.
#+BEGIN_SRC python
class Person:
  def __init__(self, fname, lname):
    self.firstname = fname
    self.lastname = lname

  def printname(self):
    print(self.firstname, self.lastname)

class Student(Person):
  def __init__(self, fname1, lname1, year):
    super().__init__(fname1, lname1)
    self.graduationyear = year

  def welcome(self):
    print("Welcome", self.firstname, self.lastname, "to the class of", self.graduationyear)

x = Student("Mike", "Olsen", 2019)

x.printname()
x.welcome()
#+END_SRC

#+RESULTS:
:RESULTS:
Mike Olsen
Welcome Mike Olsen to the class of 2019
:END:

** Iterators
- Iterators :: an object that contains a countable number of values.
- An object that can be iterated upon, meaning that you can traverse through all the values.
- An object which implements the iterator protocol, which consist of the methods __iter__() and __next__().
#+BEGIN_SRC python
mytuple = ("apple", "banana", "cherry")
myit = iter(mytuple)

print(next(myit))
print(next(myit))
print(next(myit))
#+END_SRC

#+RESULTS:
:RESULTS:
apple
banana
cherry
:END:

*** StopIteration
#+BEGIN_SRC python
class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self

  def __next__(self):
    if self.a <= 10:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration

myclass = MyNumbers()
myiter = iter(myclass)

for x in myiter:
  print(x)
#+END_SRC

#+RESULTS:
:RESULTS:
1
2
3
4
5
6
7
8
9
10
:END:

** Class Polymorphism
- Class Polymorphism :: multiple classes with the same method name.
#+BEGIN_SRC python
class Vehicle:
  def __init__(self, brand, model):
    self.brand = brand
    self.model = model

  def move(self):
    print("Move!")

class Car(Vehicle):
  pass

class Boat(Vehicle):
  def move(self):
    print("Sail!")

class Plane(Vehicle):
  def move(self):
    print("Fly!")

car1 = Car("Ford", "Mustang") #Create a Car object
boat1 = Boat("Ibiza", "Touring 20") #Create a Boat object
plane1 = Plane("Boeing", "747") #Create a Plane object

for x in (car1, boat1, plane1):
  print(x.brand)
  print(x.model)
  x.move()
#+END_SRC

#+RESULTS:
:RESULTS:
Ford
Mustang
Move!
Ibiza
Touring 20
Sail!
Boeing
747
Fly!
:END:

** JSON
- JSON :: syntax for storing and exchanging data.
- JSON is text, written with JavaScript object notation.
#+BEGIN_SRC python
import json

x = {
  "name": "John",
  "age": 30,
  "married": True,
  "divorced": False,
  "children": ("Ann","Billy"),
  "pets": None,
  "cars": [
    {"model": "BMW 230", "mpg": 27.5},
    {"model": "Ford Edge", "mpg": 24.1}
  ]
}

# convert into JSON:
y = json.dumps(x)

# the result is a JSON string:
print(y)
#+END_SRC

#+RESULTS:
:RESULTS:
{"name": "John", "age": 30, "married": true, "divorced": false, "children": ["Ann", "Billy"], "pets": null, "cars": [{"model": "BMW 230", "mpg": 27.5}, {"model": "Ford Edge", "mpg": 24.1}]}
:END:
** RegEx
- Regular Expression :: a sequence of characters that forms a search pattern.
- RegEx can be used to check if a string contains the specified search pattern.
#+BEGIN_SRC python
import re

#Check if the string starts with "The" and ends with "Spain":

txt = "The rain in Spain"
x = re.search("^The.*Spain$", txt)

if x:
  print("YES! We have a match!")
else:
  print("No match")
#+END_SRC

#+RESULTS:
:RESULTS:
YES! We have a match!
:END:
* Matplotlib
- Matplotlib :: a low level graph plotting library in python that serves as a visualization utility.
*** Version
#+BEGIN_SRC python
import matplotlib

print(matplotlib.__version__)
#+END_SRC

#+RESULTS:
:RESULTS:
3.8.2
:END:
*** Pyplot
#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

xpoints = np.array([0, 6])
ypoints = np.array([0, 250])

plt.plot(xpoints, ypoints)
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/c00e8e82858a7871d33e949ed11dd384818e8466.png]]
:END:
*** Style
#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

ypoints = np.array([3, 8, 1, 10, 5, 7])

plt.plot(ypoints, 'o:r')
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/ec6d68b40f9abde4dbbfb6f3d8b827ee83a63a46.png]]
:END:
*** Multiple Lines
#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

x1 = np.array([0, 1, 2, 3])
y1 = np.array([3, 8, 1, 10])
x2 = np.array([0, 1, 2, 3])
y2 = np.array([6, 2, 7, 11])

plt.plot(x1, y1, x2, y2)
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/9e560cfb72ff92227a78903dbfb3f230e225c0a3.png]]
:END:
*** Title and Labels
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt

x = np.array([80, 85, 90, 95, 100, 105, 110, 115, 120, 125])
y = np.array([240, 250, 260, 270, 280, 290, 300, 310, 320, 330])

font1 = {'family':'serif','color':'blue','size':20}
font2 = {'family':'serif','color':'darkred','size':15}

plt.title("Sports Watch Data", fontdict = font1)
plt.xlabel("Average Pulse", fontdict = font2)
plt.ylabel("Calorie Burnage", fontdict = font2)

plt.plot(x, y)
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/e8e84bf01a4d46cb6e370542d017da185e460e3d.png]]
:END:
*** Grid Lines
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt

x = np.array([80, 85, 90, 95, 100, 105, 110, 115, 120, 125])
y = np.array([240, 250, 260, 270, 280, 290, 300, 310, 320, 330])

plt.title("Sports Watch Data")
plt.xlabel("Average Pulse")
plt.ylabel("Calorie Burnage")

plt.plot(x, y)

plt.grid(color = 'green', linestyle = '--', linewidth = 0.5)

plt.show() 
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/9226c6d1c4373ae76185209a246b787de05ee860.png]]
:END:
*** Subplot
#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

x = np.array([0, 1, 2, 3])
y = np.array([3, 8, 1, 10])

plt.subplot(2, 3, 1)
plt.plot(x,y)
plt.title("SALES")

x = np.array([0, 1, 2, 3])
y = np.array([10, 20, 30, 40])

plt.subplot(2, 3, 2)
plt.plot(x,y)
plt.title("INCOME")

x = np.array([0, 1, 2, 3])
y = np.array([3, 8, 1, 10])

plt.subplot(2, 3, 3)
plt.plot(x,y)

x = np.array([0, 1, 2, 3])
y = np.array([10, 20, 30, 40])

plt.subplot(2, 3, 4)
plt.plot(x,y)

x = np.array([0, 1, 2, 3])
y = np.array([3, 8, 1, 10])

plt.subplot(2, 3, 5)
plt.plot(x,y)

x = np.array([0, 1, 2, 3])
y = np.array([10, 20, 30, 40])

plt.subplot(2, 3, 6)
plt.plot(x,y)

plt.suptitle("MY SHOP")
plt.show() 
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/03965de1488c484e89a4aad76cf5b4e8fcf85a07.png]]
:END:
*** Scatter
#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

x = np.array([5,7,8,7,2,17,2,9,4,11,12,9,6])
y = np.array([99,86,87,88,111,86,103,87,94,78,77,85,86])
colors = np.array([0, 10, 20, 30, 40, 45, 50, 55, 60, 70, 80, 90, 100])

plt.scatter(x, y, c=colors, cmap='viridis')

plt.colorbar()

plt.show()  
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/52ee4ad25d34d382c5971bb45572bef75d86f1ad.png]]
:END:
#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

x = np.random.randint(100, size=(100))
y = np.random.randint(100, size=(100))
colors = np.random.randint(100, size=(100))
sizes = 10 * np.random.randint(100, size=(100))

plt.scatter(x, y, c=colors, s=sizes, alpha=0.5, cmap='nipy_spectral')

plt.colorbar()

plt.show() 
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/633e3eba145427819ec2316cfb2722d004f92fb6.png]]
:END:
*** Bar
#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

x = np.array(["A", "B", "C", "D"])
y = np.array([3, 8, 1, 10])

plt.bar(x, y, color = "#4CAF50", width = 0.3)
plt.show()

plt.barh(x, y, color = "red", height = 0.7)
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/8bdf37df1ce6c6388ff3747eb4e24d2a241c7b14.png]]
[[file:./.ob-jupyter/d340f422e4ef4323e2675762bfe245f00b85db79.png]]
:END:
*** Histogram
#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

x = np.random.normal(170, 10, 250)

plt.hist(x)
plt.show() 
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/5a059723e8c6ae6587c98dc77b20bb9e58dcfd6b.png]]
:END:
*** Pie Charts
#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

y = np.array([35, 25, 25, 15])
mylabels = ["Apples", "Bananas", "Cherries", "Dates"]

plt.pie(y, labels = mylabels)
plt.legend(title = "Four Fruits:")
plt.show() 
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/b8e2af1693c6275601ba43979418103e6842ce09.png]]
:END:
#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

y = np.array([35, 25, 25, 15])
mylabels = ["Apples", "Bananas", "Cherries", "Dates"]
myexplode = [0.2, 0, 0, 0]

plt.pie(y, labels = mylabels, explode = myexplode, shadow = True)
plt.show() 
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/3846b3903802b3c72e905db77765c4def854dcb5.png]]
:END:
* NumPy
** Definition
- Numpy :: a Python library used for working with arrays.
- It also has functions for working in domain of linear algebra, fourier transform, and matrices.
- The array object in NumPy is called ndarray, it provides a lot of supporting functions that make working with ndarray very easy.
- NumPy arrays are stored at one continuous place in memory unlike lists, so processes can access and manipulate them very efficiently. This behavior is called locality of reference in computer science.
- This is the main reason why NumPy is faster than lists. Also it is optimized to work with latest CPU architectures.
** Version
#+BEGIN_SRC python :results output drawer
import numpy as np

print(np.__version__)
#+END_SRC

#+RESULTS:
:results:
1.26.1
:end:
** NumPy ndarray Object
- ndarray :: array object in NumPy
#+BEGIN_SRC python
import numpy as np

arr = np.array([1, 2, 3, 4, 5]) # pass a list
arr1 = np.array((1, 2, 3, 4, 5)) # pass a tuple
print(arr)
print(type(arr))
print(arr1)
print(type(arr1))
#+END_SRC

#+RESULTS:
:RESULTS:
[1 2 3 4 5]
<class 'numpy.ndarray'>
[1 2 3 4 5]
<class 'numpy.ndarray'>
:END:
** Dimensions in Arrays
- Dimension in arrays :: one level of array depth (nested arrays).
- Nested array :: arrays that have arrays as their elements.
#+BEGIN_SRC python
import numpy as np

arr0 = np.array(42) # 0-D array
arr1 = np.array([1, 2, 3, 4, 5]) # 1-D array
arr2 = np.array([[1, 2, 3], [4, 5, 6]]) # 2-D array
arr3 = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]) # 3-D array
arr5 = np.array([1, 2, 3, 4], ndmin=5) # Higher dimension
txt = "{}-dim: \n{}\n {}-dim: \n{}\n {}-dim: \n{}\n {}-dim:\n{}\n {}-dim:\n {}"
print(txt.format(arr0.ndim, arr0, arr1.ndim, arr1, arr2.ndim, arr2, arr3.ndim, arr3, arr5.ndim, arr5)) 
#+END_SRC

#+RESULTS:
:RESULTS:
0-dim: 
42
 1-dim: 
[1 2 3 4 5]
 2-dim: 
[[1 2 3]
 [4 5 6]]
 3-dim:
[[[ 1  2  3]
  [ 4  5  6]]

 [[ 7  8  9]
  [10 11 12]]]
 5-dim:
 [[[[[1 2 3 4]]]]]
:END:
** Array Indexing
- Array Indexing :: accessing an array element by referring to its index number.
- The indexes in NumPy arrays start with 0, meaning that the first element has index 0, and the second has index 1 etc.
*** Access 2-D Arrays
#+BEGIN_SRC python
import numpy as np

arr = np.array([[1,2,3,4,5], [6,7,8,9,10]])

print('5th element on 2nd row: ', arr[1, 4]) # Access the element on the 2nd row, 5th column
#+END_SRC

#+RESULTS:
:RESULTS:
5th element on 2nd row:  10
:END:
*** Access 3-D Arrays
#+BEGIN_SRC python
"""
The first number represents the first dimension, which contains two arrays:
[[1, 2, 3], [4, 5, 6]]
and:
[[7, 8, 9], [10, 11, 12]]
Since we selected 0, we are left with the first array:
[[1, 2, 3], [4, 5, 6]]

The second number represents the second dimension, which also contains two arrays:
[1, 2, 3]
and:
[4, 5, 6]
Since we selected 1, we are left with the second array:
[4, 5, 6]

The third number represents the third dimension, which contains three values:
4
5
6
Since we selected 2, we end up with the third value:
"""
import numpy as np

arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])

print(arr[0, 1, 2])
#+END_SRC

#+RESULTS:
:RESULTS:
6
:END:
*** Negative Indexing
#+BEGIN_SRC python
import numpy as np

arr = np.array([[1,2,3,4,5], [6,7,8,9,10]])

print('Last element from 2nd dim: ', arr[1, -1])  # Print the last element from the 2nd dim
#+END_SRC

#+RESULTS:
:RESULTS:
Last element from 2nd dim:  10
:END:
** NumPy Array Slicing
- Slicing :: taking elements from one given index to another given index.
- Syntax :: /[start:end:step]/
*** Step
#+BEGIN_SRC python
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7])

print(arr[1:5:2]) # Return every other element from index 1 to index 5
#+END_SRC

#+RESULTS:
:RESULTS:
[2 4]
:END:
#+BEGIN_SRC python
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7])

print(arr[::2])  # Return every other element from the entire array
#+END_SRC

#+RESULTS:
:RESULTS:
[1 3 5 7]
:END:
*** Negative Slicing
#+BEGIN_SRC python
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7])

print(arr[-3:-1])  # Slice from the index 3 from the end to index 1 from the end
#+END_SRC

#+RESULTS:
:RESULTS:
[5 6]
:END:
*** Slicing 2-D Arrays
#+BEGIN_SRC python
import numpy as np

arr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])

print(arr[1, 1:4])   # From the second element, slice elements from index 1 to index 4 (not included)
#+END_SRC

#+RESULTS:
:RESULTS:
[7 8 9]
:END:
#+BEGIN_SRC python
import numpy as np

arr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])

print(arr[0:2, 2]) # From both elements, return index 2
#+END_SRC

#+RESULTS:
:RESULTS:
[3 8]
:END:
#+BEGIN_SRC python
import numpy as np

arr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])

print(arr[0:2, 1:4])  # From both elements, slice index 1 to index 4 (not included), this will return a 2-D array
#+END_SRC

#+RESULTS:
:RESULTS:
[[2 3 4]
 [7 8 9]]
:END:
** NumPy Data Types
*** Data Types in NumPy
    i - integer
    b - boolean
    u - unsigned integer
    f - float
    c - complex float
    m - timedelta
    M - datetime
    O - object
    S - string
    U - unicode string
    V - fixed chunk of memory for other type ( void )
*** Creating Arrays With a Defined Data Type
#+BEGIN_SRC python
import numpy as np

arr = np.array([1, 2, 3, 4], dtype='S')

print(arr)
print(arr.dtype) # Create an array with data type string
#+END_SRC

#+RESULTS:
:RESULTS:
[b'1' b'2' b'3' b'4']
| S1 |
:END:
*** Converting Data Type on Existing Arrays
#+BEGIN_SRC python
import numpy as np

arr = np.array([1.1, 2.1, 3.1])

newarr = arr.astype('i')

print(newarr)
print(newarr.dtype)  # Change data type from float to integer by using 'i' as parameter value
#+END_SRC

#+RESULTS:
:RESULTS:
[1 2 3]
int32
:END:
** NumPy Array Copy vs View
- Copy :: a new array. The copy owns the data.
- View :: a view of the original array. The view does not own the data.
- Every NumPy array has the attribute base that returns None if the array owns the data.
#+BEGIN_SRC python
import numpy as np
# Make a copy, change the original array, and display both arrays:
arr = np.array([1, 2, 3, 4, 5])
x = arr.copy()
arr[0] = 42

print(arr)
print(x)
#+END_SRC

#+RESULTS:
:RESULTS:
[42  2  3  4  5]
[1 2 3 4 5]
:END:
#+BEGIN_SRC python
import numpy as np
# Make a view, change the original array, and display both arrays:
arr = np.array([1, 2, 3, 4, 5])
x = arr.view()
arr[0] = 42

print(arr)
print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[42  2  3  4  5]
[42  2  3  4  5]
:END:
#+BEGIN_SRC python
import numpy as np
# Print the value of the base attribute to check if an array owns it's data or not:
arr = np.array([1, 2, 3, 4, 5])

x = arr.copy()
y = arr.view()

print(x.base)
print(y.base) 
#+END_SRC

#+RESULTS:
:RESULTS:
None
[1 2 3 4 5]
:END:
** NumPy Array Shape
- Shape of an array :: the number of elements in each dimension.
#+BEGIN_SRC python
import numpy as np

arr = np.array([12, 40, 70], ndmin=5)

print(arr)
print('shape of array :', arr.shape)
#+END_SRC

#+RESULTS:
:RESULTS:
[[[[[12 40 70]]]]]
shape of array : (1, 1, 1, 1, 3)
:END:
** NumPy Array Reshaping
- Reshaping :: changing the shape of an array.
- We can reshape into any shape as long as the elements required for reshaping are equal in both shapes.
- Flattening array :: converting a multidimensional array into a 1D array.
#+BEGIN_SRC python
import numpy as np
# Convert the following 1-D array with 12 elements into a 2-D array.
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])

newarr = arr.reshape(4, 3)

print(newarr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[[ 1  2  3]
 [ 4  5  6]
 [ 7  8  9]
 [10 11 12]]
:END:
#+BEGIN_SRC python
import numpy as np
# Convert the following 1-D array with 12 elements into a 3-D array.
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])

newarr = arr.reshape(2, 3, 2)

print(newarr)
print(newarr.base) # returns the original array, so it is a view rather than copy.
#+END_SRC

#+RESULTS:
:RESULTS:
[[[ 1  2]
  [ 3  4]
  [ 5  6]]

 [[ 7  8]
  [ 9 10]
  [11 12]]]
[ 1  2  3  4  5  6  7  8  9 10 11 12]
:END:
#+BEGIN_SRC python
"""
Unknown Dimension
You are allowed to have one "unknown" dimension.
Meaning that you do not have to specify an exact number for one of the dimensions in the reshape method.
Pass -1 as the value, and NumPy will calculate this number for you.
"""
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])

newarr = arr.reshape(2, 2, -1)

print(newarr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[[[1 2]
  [3 4]]

 [[5 6]
  [7 8]]]
:END:
#+BEGIN_SRC python
import numpy as np
# Flatenning array with reshape(-1)
arr = np.array([[1, 2, 3], [4, 5, 6]])

newarr = arr.reshape(-1)

print(newarr)
#+END_SRC

** NumPy Array Iterating
- Iterating :: going through elements one by one.
*** For Loop
#+BEGIN_SRC python
import numpy as np

arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])

for x in arr:
  print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[[1 2 3]
 [4 5 6]]
[[ 7  8  9]
 [10 11 12]]
:END:
#+BEGIN_SRC python
import numpy as np

arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])

for x in arr:
  for y in x:
    for z in y:
      print(z)  
#+END_SRC

#+RESULTS:
:RESULTS:
1
2
3
4
5
6
7
8
9
10
11
12
:END:
#+BEGIN_SRC python
import numpy as np

arr = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])

for x in np.nditer(arr):
  print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
1
2
3
4
5
6
7
8
:END:
*** nditer()
#+BEGIN_SRC python
import numpy as np

arr = np.array([1, 2, 3])

for x in np.nditer(arr, flags=['buffered'], op_dtypes=['S']):
  print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
b'1'
b'2'
b'3'
:END:
#+BEGIN_SRC python
import numpy as np

arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])

for x in np.nditer(arr[:, ::2]):
  print(x)  
#+END_SRC

#+RESULTS:
:RESULTS:
1
3
5
7
:END:
*** ndenumerate()
- Enumeration :: mentioning sequence number of somethings one by one.
#+BEGIN_SRC python
import numpy as np

arr = np.array([1, 2, 3])

for idx, x in np.ndenumerate(arr):
  print(idx, x)  
#+END_SRC

#+RESULTS:
:RESULTS:
(0,) 1
(1,) 2
(2,) 3
:END:

#+BEGIN_SRC python
import numpy as np

arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])

for idx, x in np.ndenumerate(arr):
  print(idx, x)   
#+END_SRC

#+RESULTS:
:RESULTS:
(0, 0) 1
(0, 1) 2
(0, 2) 3
(0, 3) 4
(1, 0) 5
(1, 1) 6
(1, 2) 7
(1, 3) 8
:END:
** Numpy Joining Array
- Joining :: putting contents of two or more arrays in a single array.
- In NumPy we join arrays by axes.
*** concatenate()
#+BEGIN_SRC python
import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
arr = np.concatenate((arr1, arr2))

print(arr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[1 2 3 4 5 6]
:END:
#+BEGIN_SRC python
import numpy as np

arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[5, 6], [7, 8]])
arr = np.concatenate((arr1, arr2), axis=1)

print(arr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[[1 2 5 6]
 [3 4 7 8]]
:END:
*** stack()
- Stacking is same as concatenation, the only difference is that stacking is done along a new axis.
- We can concatenate two 1-D arrays along the second axis which would result in putting them one over the other, ie. stacking.
#+BEGIN_SRC python
import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
arr = np.stack((arr1, arr2), axis=1)

print(arr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[[1 4]
 [2 5]
 [3 6]]
:END:
*** Stacking Along Rows - hstack()
#+BEGIN_SRC python
import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
arr = np.hstack((arr1, arr2))

print(arr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[1 2 3 4 5 6]
:END:
*** Stacking Along Columns - vstack()
#+BEGIN_SRC python
import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
arr = np.vstack((arr1, arr2))

print(arr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[[1 2 3]
 [4 5 6]]
:END:

*** Stacking Along Height (depth) - dstack()
#+BEGIN_SRC python
import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
arr = np.dstack((arr1, arr2))

print(arr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[[[1 4]
  [2 5]
  [3 6]]]
:END:

** NumPy Splitting Array
- Splitting :: reverse operation of Joining. Splitting breaks one array into multiple.
*** array_split()
#+BEGIN_SRC python
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6])
newarr = np.array_split(arr, 4)

print(newarr) # The return value is a list containing four arrays.
#+END_SRC

#+RESULTS:
:RESULTS:
[array([1, 2]), array([3, 4]), array([5]), array([6])]
:END:
#+BEGIN_SRC python
import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]])
newarr = np.array_split(arr, 3, axis=1)

print(newarr)
print(newarr[0])
print(newarr[1])
print(newarr[2])
#+END_SRC

#+RESULTS:
:RESULTS:
[array([[ 1],
       [ 4],
       [ 7],
       [10],
       [13],
       [16]]), array([[ 2],
       [ 5],
       [ 8],
       [11],
       [14],
       [17]]), array([[ 3],
       [ 6],
       [ 9],
       [12],
       [15],
       [18]])]
[[ 1]
 [ 4]
 [ 7]
 [10]
 [13]
 [16]]
[[ 2]
 [ 5]
 [ 8]
 [11]
 [14]
 [17]]
[[ 3]
 [ 6]
 [ 9]
 [12]
 [15]
 [18]]
:END:
*** hsplit()
#+BEGIN_SRC python
import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]])
newarr = np.hsplit(arr, 3)

print(newarr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[array([[ 1],
       [ 4],
       [ 7],
       [10],
       [13],
       [16]]), array([[ 2],
       [ 5],
       [ 8],
       [11],
       [14],
       [17]]), array([[ 3],
       [ 6],
       [ 9],
       [12],
       [15],
       [18]])]
:END:
*** vsplit()
*** dsplit()
** NumPy Searching Arrays
*** where()
#+BEGIN_SRC python
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 4, 4])
x = np.where(arr == 4)

print(x) # the value 4 is present at index 3, 5, and 6.
#+END_SRC

#+RESULTS:
:RESULTS:
(array([3, 5, 6]),)
:END:
*** searchsorted()
#+BEGIN_SRC python
import numpy as np

arr = np.array([6, 7, 8, 9])
x = np.searchsorted(arr, 7)

print(x) # The number 7 should be inserted on index 1 to remain the sort order.
#+END_SRC

#+RESULTS:
:RESULTS:
1
:END:
#+BEGIN_SRC python
import numpy as np

arr = np.array([1, 3, 5, 7])
x = np.searchsorted(arr, [2, 4, 6])

print(x) # [1 2 3] containing the three indexes where 2, 4, 6 would be inserted in the original array to maintain the order.
#+END_SRC

#+RESULTS:
:RESULTS:
[1 2 3]
:END:
** NumPy Sorting Arrays
- Sorting :: putting elements in an /ordered sequence/.
- Ordered sequence :: any sequence that has an order corresponding to elements, like numeric or alphabetical, ascending or descending.
#+BEGIN_SRC python
import numpy as np

arr = np.array([3, 2, 0, 1])

print(np.sort(arr)) 
#+END_SRC

#+RESULTS:
:RESULTS:
[0 1 2 3]
:END:
#+BEGIN_SRC python
import numpy as np

arr = np.array(['banana', 'cherry', 'apple'])

print(np.sort(arr)) 
#+END_SRC

#+RESULTS:
:RESULTS:
['apple' 'banana' 'cherry']
:END:

#+BEGIN_SRC python
import numpy as np

arr = np.array([True, False, True])

print(np.sort(arr)) 
#+END_SRC

#+RESULTS:
:RESULTS:
[False  True  True]
:END:

#+BEGIN_SRC python
import numpy as np

arr = np.array([[3, 2, 4], [5, 0, 1]])

print(np.sort(arr)) 
#+END_SRC

#+RESULTS:
:RESULTS:
[[2 3 4]
 [0 1 5]]
:END:
** NumPy Filter Array
- Filtering :: Getting some elements out of an existing array and creating a new array out of them.
- In NumPy, you filter an array using a boolean index list.
- Boolean index list :: a list of booleans corresponding to indexes in the array.
#+BEGIN_SRC python
import numpy as np

arr = np.array([41, 42, 43, 44])
x = [True, False, True, False]
newarr = arr[x]

print(newarr) # If the value at an index is True that element is contained in the filtered array, if the value at that index is False that element is excluded from the filtered array.
#+END_SRC

#+RESULTS:
:RESULTS:
[41 43]
:END:
#+BEGIN_SRC python
import numpy as np
#Create a filter array that will return only values higher than 42:
arr = np.array([41, 42, 43, 44])
filter_arr = arr > 42
newarr = arr[filter_arr]

print(filter_arr)
print(newarr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[False False  True  True]
[43 44]
:END:

#+BEGIN_SRC python
import numpy as np
# Create a filter array that will return only even elements from the original array:
arr = np.array([1, 2, 3, 4, 5, 6, 7])
filter_arr = arr % 2 == 0
newarr = arr[filter_arr]

print(filter_arr)
print(newarr) 
#+END_SRC

* NumPy Random
** Generate Random Numbers
- Random :: something that can not be predicted logically.
- Random number does NOT mean a different number every time.
- Pseudo random :: Random numbers generated through a generation algorithm.
- In order to generate a truly random number on our computers we need to get the random data from some outside source. This outside source is generally our keystrokes, mouse movements, data on network etc.
*** Random Numbers
#+BEGIN_SRC python
from numpy import random

x = random.randint(100)

print(x)
#+END_SRC

#+RESULTS:
:RESULTS:
69
:END:
*** Random Float
#+BEGIN_SRC python
from numpy import random

x = random.rand()

print(x)
#+END_SRC

#+RESULTS:
:RESULTS:
0.4632936289301216
:END:
*** Random Array
#+BEGIN_SRC python
from numpy import random
# Generate a 2-D array with 3 rows, each row containing 5 random integers from 0 to 100:
x = random.randint(100, size=(3, 5))

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[[20 46 25 13 91]
 [54 77 18 12 45]
 [21 19 29 46 42]]
:END:
#+BEGIN_SRC python
from numpy import random
# Generate a 2-D array with 3 rows, each row containing 5 random numbers:
x = random.rand(3, 5)

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[[0.69539986 0.4183036  0.51323966 0.27327261 0.38662208]
 [0.9333368  0.74796625 0.62393512 0.35587711 0.69137102]
 [0.14452775 0.32223257 0.20612338 0.54943597 0.24571138]]
:END:
*** Generate Random Number From Array
#+BEGIN_SRC python
from numpy import random
# Return one of the values in an array:
x = random.choice([3, 5, 7, 9])

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
5
:END:
#+BEGIN_SRC python
from numpy import random
# Generate a 2-D array that consists of the values in the array parameter (3, 5, 7, and 9):
x = random.choice([3, 5, 7, 9], size=(3, 5))

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[[5 7 7 3 7]
 [9 3 5 7 7]
 [5 3 5 9 9]]
:END:
** Random Data Distribution
- Data distribution :: a list of all possible values, and how often each value occurs.
- Random distribution :: a set of random numbers that follow a certain /probability density function/.
- Probability density function :: a function that describes a continuous probability. i.e. probability of all values in an array.
- Probability :: a number between 0 and 1, where 0 means that the value will never occur and 1 means that the value will always occur.
#+BEGIN_SRC python
"""
Generate a 1-D array containing 100 values, where each value has to be 3, 5, 7 or 9.

The probability for the value to be 3 is set to be 0.1
The probability for the value to be 5 is set to be 0.3
The probability for the value to be 7 is set to be 0.6

The probability for the value to be 9 is set to be 0Generate a 1-D array containing 100 values, where each value has to be 3, 5, 7 or 9.
The probability for the value to be 3 is set to be 0.1
The probability for the value to be 5 is set to be 0.3
The probability for the value to be 7 is set to be 0.6
The probability for the value to be 9 is set to be 0
"""

from numpy import random

x = random.choice([3, 5, 7, 9], p=[0.1, 0.3, 0.6, 0.0], size=(100))

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[3 7 7 5 7 7 7 7 7 7 7 5 7 7 3 7 5 5 7 7 7 3 7 7 7 3 7 7 5 7 7 7 7 7 5 5 7
 7 7 7 7 7 7 3 7 7 7 7 5 5 7 5 7 3 5 5 5 7 7 7 3 5 7 3 7 3 5 5 5 5 5 5 5 7
 7 7 5 5 7 7 7 7 7 5 7 7 5 5 7 5 7 5 7 7 7 7 7 5 7 7]
:END:
#+BEGIN_SRC python
from numpy import random
# return a 2-D array with 3 rows, each containing 5 values.
x = random.choice([3, 5, 7, 9], p=[0.1, 0.3, 0.6, 0.0], size=(3, 5))

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[[5 7 5 5 7]
 [5 5 7 7 7]
 [7 5 7 5 5]]
:END:
** Random Permutations
- Permutations :: an arrangement of elements. e.g. [3, 2, 1] is a permutation of [1, 2, 3] and vice-versa.
*** Shuffling Arrays
- Shuffle :: changing arrangement of elements in-place. i.e. in the array itself.
- The shuffle() method makes changes to the original array.
#+BEGIN_SRC python
from numpy import random
import numpy as np
# The shuffle() method makes changes to the original array.
arr = np.array([1, 2, 3, 4, 5])

random.shuffle(arr)

print(arr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[1 2 4 5 3]
:END:
*** Generating Permutation of Arrays
- The permutation() method returns a re-arranged array (and leaves the original array un-changed).
#+BEGIN_SRC python
from numpy import random
import numpy as np
# The permutation() method returns a re-arranged array (and leaves the original array un-changed).
arr = np.array([1, 2, 3, 4, 5])

print(random.permutation(arr)) 
#+END_SRC

#+RESULTS:
:RESULTS:
[2 3 4 5 1]
:END:

** Visualize Distributions With Seaborn
- Seaborn :: a library that uses Matplotlib underneath to plot graphs. It will be used to visualize random distributions.
- Distplots :: stands for distribution plot, it takes as input an array and plots a curve corresponding to the distribution of points in the array.
#+BEGIN_SRC python
import matplotlib.pyplot as plt
import seaborn as sns

sns.distplot([0, 1, 2, 3, 4, 5], hist=False)

plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
/tmp/ipykernel_375489/2406393504.py:4: UserWarning: 

`distplot` is a deprecated function and will be removed in seaborn v0.14.0.

Please adapt your code to use either `displot` (a figure-level function with
similar flexibility) or `kdeplot` (an axes-level function for kernel density plots).

For a guide to updating your code to use the new functions, please see
https://gist.github.com/mwaskom/de44147ed2974457ad6372750bbe5751

  sns.distplot([0, 1, 2, 3, 4, 5], hist=False)
[[file:./.ob-jupyter/a4f5d70020db7912b4eea018c61133c73c7c533d.png]]
:END:
** Normal Distribution
#+BEGIN_SRC python
from numpy import random
# Generate a random normal distribution of size 2x3 with mean at 1 and standard deviation of 2:
x = random.normal(loc=1, scale=2, size=(2, 3))

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[[ 0.49167822  0.95282251  3.29455706]
 [-0.06679489 -2.98498386 -2.49789266]]
:END:
#+BEGIN_SRC python
from numpy import random
import matplotlib.pyplot as plt
import seaborn as sns

sns.distplot(random.normal(size=1000), hist=False)

plt.show() 
#+END_SRC

#+RESULTS:
:RESULTS:
/tmp/ipykernel_375489/1078012762.py:5: UserWarning: 

`distplot` is a deprecated function and will be removed in seaborn v0.14.0.

Please adapt your code to use either `displot` (a figure-level function with
similar flexibility) or `kdeplot` (an axes-level function for kernel density plots).

For a guide to updating your code to use the new functions, please see
https://gist.github.com/mwaskom/de44147ed2974457ad6372750bbe5751

  sns.distplot(random.normal(size=1000), hist=False)
[[file:./.ob-jupyter/f9c17a06995f60c75816c02d90e497bb9984d861.png]]
:END:
** Binomial Distribution
- Binomial Distribution :: Discrete Distribution. It describes the outcome of binary scenarios, e.g. toss of a coin, it will either be head or tails.
- Discrete Distribution :: The distribution is defined at separate set of events, e.g. a coin toss's result is discrete as it can be only head or tails whereas height of people is continuous as it can be 170, 170.1, 170.11 and so on.
#+BEGIN_SRC python
from numpy import random
import matplotlib.pyplot as plt
import seaborn as sns

x = random.binomial(n=10, p=0.5, size=1000)
sns.histplot(x, kde=True) # kde = Plot univariate or bivariate distributions using kernel density estimation.

print(x)
plt.show() 
#+END_SRC

#+RESULTS:
:RESULTS:
[3 6 4 4 4 5 3 7 4 7 4 5 2 8 4 4 5 4 5 3 5 1 5 6 4 4 6 6 4 4 1 4 2 6 3 3 4
 5 3 2 4 8 5 5 7 4 3 6 5 4 4 3 3 3 5 5 4 4 5 3 8 6 8 3 7 6 6 5 4 7 8 5 4 5
 5 8 4 5 4 7 7 3 5 6 7 4 7 5 5 4 5 5 4 5 6 4 2 6 3 6 7 5 4 3 5 7 5 5 4 4 6
 7 3 6 4 3 5 5 6 5 6 6 5 6 4 4 5 3 6 3 5 3 6 5 7 5 7 5 6 5 5 6 6 4 4 5 8 4
 6 4 4 7 4 5 9 5 5 6 4 6 5 4 4 5 3 3 4 6 4 7 3 6 6 5 4 5 4 4 1 5 1 7 4 3 4
 6 3 7 7 5 5 6 3 3 7 5 3 3 5 3 3 4 6 5 6 6 3 4 3 3 6 5 5 5 6 6 4 6 3 6 7 4
 5 4 5 6 4 5 6 6 8 6 3 7 5 6 3 4 5 4 7 7 7 3 6 8 3 4 7 1 3 3 5 1 4 5 5 5 6
 6 8 4 5 5 5 5 6 4 8 7 6 3 4 4 4 7 3 3 4 3 6 8 7 5 2 2 4 5 5 8 6 5 3 4 5 7
 6 6 8 3 5 6 3 4 6 4 6 6 5 4 5 5 3 7 3 5 4 5 3 4 6 6 5 6 7 3 4 7 5 6 5 4 1
 7 5 4 6 7 5 1 4 5 4 4 6 4 3 6 6 7 9 4 7 4 6 4 7 4 8 3 6 5 3 3 5 4 7 6 6 8
 5 4 2 5 8 6 7 3 7 5 5 7 2 4 2 5 4 4 3 6 3 6 4 6 6 7 4 4 3 5 4 5 7 6 5 4 4
 4 9 4 5 7 6 4 5 4 6 1 3 2 4 4 6 8 3 8 5 4 1 6 5 5 4 5 2 7 4 5 4 5 6 5 6 7
 5 5 4 9 6 5 4 5 5 7 9 3 5 3 2 6 3 4 6 7 2 2 4 5 5 7 5 3 8 4 3 7 7 4 4 4 6
 7 6 7 5 6 4 3 6 5 4 7 5 6 5 5 4 6 1 8 7 3 4 3 7 7 5 5 3 3 5 5 4 4 1 5 5 7
 3 3 5 3 6 5 6 9 6 4 6 9 8 5 9 3 5 2 6 4 7 3 6 5 5 4 6 6 7 7 6 4 7 6 3 4 2
 5 4 7 6 9 6 4 3 7 5 6 2 6 2 6 7 5 6 5 5 5 5 3 6 5 5 4 5 5 5 5 4 4 7 4 3 5
 7 6 3 3 5 7 4 6 6 3 3 8 4 2 6 7 4 8 4 9 7 4 4 4 2 7 3 3 4 7 6 4 3 8 4 4 4
 2 2 1 6 7 2 4 5 6 5 6 4 7 4 2 6 8 6 6 4 6 4 7 6 4 6 5 6 3 5 4 7 7 6 5 6 2
 8 3 8 7 7 6 4 2 6 5 8 7 5 5 4 5 4 6 7 4 4 6 5 5 5 4 5 7 7 4 6 2 5 6 3 6 4
 5 4 3 3 6 5 4 7 4 6 7 4 5 7 4 3 3 3 6 4 7 6 4 6 5 5 4 2 7 4 5 5 5 4 7 2 6
 6 5 3 6 4 4 7 6 5 8 3 8 2 4 6 7 5 6 6 3 3 7 6 5 7 8 4 4 2 4 6 5 2 5 5 5 5
 5 5 5 6 4 5 4 6 6 6 6 5 7 4 6 5 4 6 4 4 5 6 5 2 4 5 2 5 4 8 6 8 6 7 8 6 6
 8 8 8 3 2 4 5 6 5 6 5 6 9 6 4 4 5 3 5 8 8 7 8 4 4 2 7 4 3 4 7 4 5 2 6 5 4
 1 5 1 4 6 5 7 3 6 5 6 8 5 3 4 6 5 6 6 6 3 7 6 4 5 5 6 5 7 3 5 4 6 8 6 7 5
 3 4 4 5 5 6 4 6 4 5 5 6 6 5 4 5 2 5 4 5 6 5 4 4 6 1 5 5 5 4 4 3 2 5 5 5 5
 5 3 6 5 4 6 6 5 5 4 4 4 1 6 2 4 8 4 4 5 5 5 4 8 2 4 4 6 4 7 5 6 5 5 4 4 3
 6 5 2 5 8 3 6 3 3 1 7 5 5 6 7 7 5 5 6 5 6 7 2 8 6 3 2 5 6 4 2 3 4 5 7 8 4
 6]
[[file:./.ob-jupyter/59cc7aec2f62713c330a0822cdae13237e84f5f0.png]]
:END:

#+BEGIN_SRC python
from numpy import random
import matplotlib.pyplot as plt
import seaborn as sns

data1 = random.normal(loc=50, scale=5, size=1000)
data2 = random.binomial(n=100, p=0.5, size=1000)

data = {"Normal":data1, "Binomial":data2}
sns.displot(data, kind='kde')
#+END_SRC

#+RESULTS:
:RESULTS:
/home/plchu/miniconda3/envs/scimax/lib/python3.11/site-packages/seaborn/axisgrid.py:123: UserWarning: The figure layout has changed to tight
  self._figure.tight_layout(*args, **kwargs)
: <seaborn.axisgrid.FacetGrid at 0x7ff31085bd90>
[[file:./.ob-jupyter/80b5639877d066f407c7791db1ecbcf705e63467.png]]
:END:
** Poisson Distribution
- Poisson distribution :: Discrete distribution. It estimates how many times an event can happen in a specified time. e.g. If someone eats twice a day what is the probability he will eat thrice?
#+BEGIN_SRC python
from numpy import random

x = random.poisson(lam=2, size=10)

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[2 3 0 4 1 1 3 2 2 2]
:END:
#+BEGIN_SRC python
from numpy import random
import seaborn as sns

sns.displot(random.poisson(lam=2, size=1000), kde=False)
#+END_SRC

#+RESULTS:
:RESULTS:
/home/plchu/miniconda3/envs/scimax/lib/python3.11/site-packages/seaborn/axisgrid.py:123: UserWarning: The figure layout has changed to tight
  self._figure.tight_layout(*args, **kwargs)
: <seaborn.axisgrid.FacetGrid at 0x7ff310378c50>
[[file:./.ob-jupyter/6e8307a042a24b75914e59944c8cea0febe54b48.png]]
:END:
#+BEGIN_SRC python
from numpy import random
import seaborn as sns

data1 = random.normal(loc=50, scale=7, size=1000)
data2 = random.poisson(lam=50, size=1000)
data3 = random.binomial(n=5000, p=0.01, size=1000) # np ~ lam

data = {"Normal":data1, "Poisson":data2, "Binomial":data3}
sns.displot(data, kind="kde")
#+END_SRC

#+RESULTS:
:RESULTS:
/home/plchu/miniconda3/envs/scimax/lib/python3.11/site-packages/seaborn/axisgrid.py:123: UserWarning: The figure layout has changed to tight
  self._figure.tight_layout(*args, **kwargs)
: <seaborn.axisgrid.FacetGrid at 0x7ff310a6be10>
[[file:./.ob-jupyter/3da3a98c9cf688bd90cdb700bc749d3c301b662d.png]]
:END:
** Uniform Distribution
- Uniform distribution :: used to describe probability where every event has equal chances of occurring. E.g. Generation of random numbers.
#+BEGIN_SRC python
from numpy import random

x = random.uniform(size=(2, 3))

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[[0.15306971 0.3444156  0.49545693]
 [0.20677283 0.51331004 0.07387348]]
:END:
#+BEGIN_SRC python
from numpy import random
import seaborn as sns

data1 = random.uniform(size=1000)

data = {"Uniform":data1}
sns.displot(data, kind="kde")
#+END_SRC

#+RESULTS:
:RESULTS:
/home/plchu/miniconda3/envs/scimax/lib/python3.11/site-packages/seaborn/axisgrid.py:123: UserWarning: The figure layout has changed to tight
  self._figure.tight_layout(*args, **kwargs)
: <seaborn.axisgrid.FacetGrid at 0x7ff310aeda10>
[[file:./.ob-jupyter/cd903b158990424a300674eadf5b943575b2c8c4.png]]
:END:
** Logistic Distribution
- Logistic distribution :: used to describe growth. Used extensively in machine learning in logistic regression, neural networks etc.
- Both Logistic and Normal Distribution re near identical, but logistic distribution has more area under the tails, meaning it represents more possibility of occurrence of an event further away from mean.
- For higher value of scale (standard deviation) the normal and logistic distributions are near identical apart from the peak.
#+BEGIN_SRC python
from numpy import random

x = random.logistic(loc=1, scale=2, size=(2, 3))

print(x)
#+END_SRC

#+RESULTS:
:RESULTS:
[[-0.68752718  0.01299997 -1.52412743]
 [ 4.23812858  3.67214887 -2.38190205]]
:END:
#+BEGIN_SRC python
from numpy import random
import seaborn as sns

data1 = random.logistic(size=1000)

data = {"Uniform":data1}
sns.displot(data, kind="kde")
#+END_SRC

#+RESULTS:
:RESULTS:
/home/plchu/miniconda3/envs/scimax/lib/python3.11/site-packages/seaborn/axisgrid.py:123: UserWarning: The figure layout has changed to tight
  self._figure.tight_layout(*args, **kwargs)
: <seaborn.axisgrid.FacetGrid at 0x7ff30fc89d10>
[[file:./.ob-jupyter/2f512ef12fdaa7d0a0e589a25e68f19bfac45460.png]]
:END:
#+BEGIN_SRC python
import matplotlib.pyplot as plt
import seaborn as sns

data1 = random.normal(scale=2, size=1000)
data2 = random.logistic(size=1000)

data = {"Normal":data1, "Logistic":data2}
sns.displot(data, kind='kde')
#+END_SRC

#+RESULTS:
:RESULTS:
/home/plchu/miniconda3/envs/scimax/lib/python3.11/site-packages/seaborn/axisgrid.py:123: UserWarning: The figure layout has changed to tight
  self._figure.tight_layout(*args, **kwargs)
: <seaborn.axisgrid.FacetGrid at 0x7ff310d84690>
[[file:./.ob-jupyter/062c55867bfc0b6127af5fc780c696f5e5c1b0d2.png]]
:END:
** Multinomial Distribution
- Multinomial Distribution :: a generalization of binomial distribution.
- It describes outcomes of multi-nomial scenarios unlike binomial where scenarios must be only one of two. e.g. Blood type of a population, dice roll outcome.
#+BEGIN_SRC python
from numpy import random
# Multinomial samples will NOT produce a single value! They will produce one value for each pval.
x = random.multinomial(n=6, pvals=[1/6, 1/6, 1/6, 1/6, 1/6, 1/6])

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[2 0 1 2 0 1]
:END:
** Exponential Distribution
- Exponential distribution :: used for describing time till next event e.g. failure/success etc.
- Poisson distribution deals with number of occurences of an event in a time period whereas exponential distribution deals with the time between these events.
#+BEGIN_SRC python
from numpy import random
# Draw out a sample for exponential distribution with 2.0 scale with 2x3 size:
x = random.exponential(scale=2, size=(2, 3))

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[[0.03398311 3.81420725 0.34157461]
 [0.63962599 7.71823538 1.83602025]]
:END:
#+BEGIN_SRC python
from numpy import random
import seaborn as sns

data1 = random.exponential(size=1000)

data = {"Exponential":data1}
sns.displot(data, kind="kde")
#+END_SRC

#+RESULTS:
:RESULTS:
/home/plchu/miniconda3/envs/scimax/lib/python3.11/site-packages/seaborn/axisgrid.py:123: UserWarning: The figure layout has changed to tight
  self._figure.tight_layout(*args, **kwargs)
: <seaborn.axisgrid.FacetGrid at 0x7ff30fbefdd0>
[[file:./.ob-jupyter/663117ce5d3bd7a1bd524dc4576b44fcc510a772.png]]
:END:
** Chi Square Distribution
- Chi Square Distribution :: used as a basis to verify the hypothesis.
#+BEGIN_SRC python
from numpy import random

x = random.chisquare(df=2, size=(2, 3))

print(x)
#+END_SRC

#+RESULTS:
:RESULTS:
[[4.80554034 0.99033706 2.82214435]
 [0.6227165  0.41610274 3.06177105]]
:END:
#+BEGIN_SRC python
from numpy import random
import seaborn as sns

data1 = random.chisquare(df=1, size=1000)

data = {"Chi-Square":data1}
sns.displot(data, kind="kde")
#+END_SRC

#+RESULTS:
:RESULTS:
/home/plchu/miniconda3/envs/scimax/lib/python3.11/site-packages/seaborn/axisgrid.py:123: UserWarning: The figure layout has changed to tight
  self._figure.tight_layout(*args, **kwargs)
: <seaborn.axisgrid.FacetGrid at 0x7ff30fc9e090>
[[file:./.ob-jupyter/0d5b8151f16d36065491584281a7fb97b140930c.png]]
:END:
** Rayleigh Distribution
- Rayleigh Distribution :: used in signal processing.
- At unit stddev and 2 degrees of freedom rayleigh and chi square represent the same distributions. 
#+BEGIN_SRC python
from numpy import random

x = random.rayleigh(scale=2, size=(2, 3))

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[[4.87858512 2.67445948 2.6974508 ]
 [7.06928311 2.91480686 3.44555635]]
:END:
#+BEGIN_SRC python
from numpy import random
import seaborn as sns

data1 = random.rayleigh(size=1000)

data = {"Rayleigh":data1}
sns.displot(data, kind="kde")
#+END_SRC

#+RESULTS:
:RESULTS:
/home/plchu/miniconda3/envs/scimax/lib/python3.11/site-packages/seaborn/axisgrid.py:123: UserWarning: The figure layout has changed to tight
  self._figure.tight_layout(*args, **kwargs)
: <seaborn.axisgrid.FacetGrid at 0x7ff30fc34fd0>
[[file:./.ob-jupyter/0e7b6197fc066dc3b065bbec5fd4cdc42f3cfa63.png]]
:END:
** Pareto Distribution
- Pareto Distribution :: A distribution following Pareto's law i.e. 80-20 distribution (20% factors cause 80% outcome).
#+BEGIN_SRC python
from numpy import random

x = random.pareto(a=2, size=(2, 3))

print(x)
#+END_SRC

#+RESULTS:
:RESULTS:
[[0.391358   0.01054772 1.89516333]
 [0.49808851 0.75097393 1.20689382]]
:END:
#+BEGIN_SRC python
from numpy import random
import seaborn as sns

data1 = random.pareto(a=2, size=1000)

data = {"Pareto":data1}
sns.displot(data, kind="hist")
#+END_SRC

#+RESULTS:
:RESULTS:
/home/plchu/miniconda3/envs/scimax/lib/python3.11/site-packages/seaborn/axisgrid.py:123: UserWarning: The figure layout has changed to tight
  self._figure.tight_layout(*args, **kwargs)
: <seaborn.axisgrid.FacetGrid at 0x7ff30f9ef990>
[[file:./.ob-jupyter/c785d05bcb6e34bec7da1b3f38e09054a7cc343b.png]]
:END:
** Zipf Distribution
- Zipf Distribution :: used to sample data based on zipf's law.
- Zipf's law :: In a collection, the nth common term is 1/n times of the most common term. E.g. the 5th most common word in English occurs nearly 1/5 times as often as the most common word.
#+BEGIN_SRC python
from numpy import random

x = random.zipf(a=2, size=(2, 3))

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[[19  3  1]
 [ 2  1  1]]
:END:
#+BEGIN_SRC python
# from numpy import random
# import matplotlib.pyplot as plt
# import seaborn as sns

# x = random.zipf(a=2, size=1000)
# print(x)
# sns.distplot(x[x<10], kde=False)

# plt.show()

from numpy import random
import seaborn as sns

data1 = random.zipf(a=2, size=100)

data = {"Zipf":data1}
print(data1)
sns.displot(data1[data1<10], kind="hist")
#+END_SRC

#+RESULTS:
:RESULTS:
[  6   1   1   1   6   1   1   1   1   8   1   7   3 209  18   1   1   5
   1   2   1   2  10   2   1   1   1   2   3   2   2   6   1   1   1   1
   1   1   1   1   1   1   1   2   4   1   1   1   1   1   1  10   2   1
   5   1   3   9   1   4   1   2   3   1   2   6   4  12   1   2   1   1
   2   8   1   1   1   2   1   1   4   1   1   1   3   1   8  87   1   1
   1   1   6   2   1   8   2   3   1   1]
/home/plchu/miniconda3/envs/scimax/lib/python3.11/site-packages/seaborn/axisgrid.py:123: UserWarning: The figure layout has changed to tight
  self._figure.tight_layout(*args, **kwargs)
: <seaborn.axisgrid.FacetGrid at 0x7ff30dc17490>
[[file:./.ob-jupyter/6d2c3c68f25e90ef8ac565bc0f2dc717b3a60f4c.png]]
:END:
* NumPy ufuncs
** Universal functions
- ufuncs :: "Universal Functions", they are NumPy functions that operate on the ndarray object.
- ufuncs are used to implement vectorization in NumPy which is way faster than iterating over elements.
- They also provide broadcasting and additional methods like reduce, accumulate etc. that are very helpful for computation.
- Vectorization :: Converting iterative statements into a vector based operation.
- It is faster as modern CPUs are optimized for such operations.

#+BEGIN_SRC python
x = [1, 2, 3, 4]
y = [4, 5, 6, 7]
z = []

for i, j in zip(x, y):
  z.append(i + j)
print(z)
#+END_SRC

#+RESULTS:
:RESULTS:
[5, 7, 9, 11]
:END:

#+BEGIN_SRC python
import numpy as np

x = [1, 2, 3, 4]
y = [4, 5, 6, 7]
z = np.add(x, y)

print(z)
#+END_SRC

#+RESULTS:
:RESULTS:
[ 5  7  9 11]
:END:

** Create Own ufunc
- To create your own ufunc, you have to define a function, like you do with normal functions in Python, then you add it to your NumPy ufunc library with the frompyfunc() method.

#+BEGIN_SRC python
"""
The frompyfunc() method takes the following arguments:

    function - the name of the function.
    inputs - the number of input arguments (arrays).
    outputs - the number of output arrays.

"""
import numpy as np

def myadd(x, y):
  return x+y

myadd = np.frompyfunc(myadd, 2, 1)

print(myadd([1, 2, 3, 4], [5, 6, 7, 8]))
print(type(myadd))
#+END_SRC

#+RESULTS:
:RESULTS:
[6 8 10 12]
<class 'numpy.ufunc'>
:END:

** Simple Arithmetic
- Use arithmetic operators + - * / directly between NumPy arrays.
- Perform arithmetic conditionally where we have functions that can take any array-like objects e.g. lists, tuples etc.
*** Addition
#+BEGIN_SRC python
import numpy as np
# Add the values in arr1 to the values in arr2:
arr1 = np.array([10, 11, 12, 13, 14, 15])
arr2 = np.array([20, 21, 22, 23, 24, 25])

newarr = np.add(arr1, arr2)

print(newarr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[30 32 34 36 38 40]
:END:

*** Subtraction
#+BEGIN_SRC python
import numpy as np

arr1 = np.array([10, 20, 30, 40, 50, 60])
arr2 = np.array([20, 21, 22, 23, 24, 25])

newarr = np.subtract(arr1, arr2)

print(newarr)
#+END_SRC

#+RESULTS:
:RESULTS:
[-10  -1   8  17  26  35]
:END:

*** Multiplication
#+BEGIN_SRC python
import numpy as np

arr1 = np.array([10, 20, 30, 40, 50, 60])
arr2 = np.array([20, 21, 22, 23, 24, 25])

newarr = np.multiply(arr1, arr2)

print(newarr)
#+END_SRC

#+RESULTS:
:RESULTS:
[ 200  420  660  920 1200 1500]
:END:

*** Division
#+BEGIN_SRC python
import numpy as np

arr1 = np.array([10, 20, 30, 40, 50, 60])
arr2 = np.array([3, 5, 10, 8, 2, 33])

newarr = np.divide(arr1, arr2)

print(newarr)
#+END_SRC

#+RESULTS:
:RESULTS:
[ 3.33333333  4.          3.          5.         25.          1.81818182]
:END:

*** Power
#+BEGIN_SRC python
import numpy as np

arr1 = np.array([10, 20, 30, 40, 50, 60])
arr2 = np.array([3, 5, 6, 8, 2, 33])

newarr = np.power(arr1, arr2)

print(newarr)
#+END_SRC

#+RESULTS:
:RESULTS:
[         1000       3200000     729000000 6553600000000          2500
             0]
:END:

*** Remainder
#+BEGIN_SRC python
import numpy as np

arr1 = np.array([10, 20, 30, 40, 50, 60])
arr2 = np.array([3, 7, 9, 8, 2, 33])

newarr = np.mod(arr1, arr2)

print(newarr)
#+END_SRC

#+RESULTS:
:RESULTS:
[ 1  6  3  0  0 27]
:END:

#+BEGIN_SRC python
import numpy as np

arr1 = np.array([10, 20, 30, 40, 50, 60])
arr2 = np.array([3, 7, 9, 8, 2, 33])

newarr = np.remainder(arr1, arr2)

print(newarr)
#+END_SRC

#+RESULTS:
:RESULTS:
[ 1  6  3  0  0 27]
:END:

*** Quotient and Mod
#+BEGIN_SRC python
import numpy as np
# The divmod() function return both the quotient and the the mod. The return value is two arrays, the first array contains the quotient and second array contains the mod.

arr1 = np.array([10, 20, 30, 40, 50, 60])
arr2 = np.array([3, 7, 9, 8, 2, 33])

newarr = np.divmod(arr1, arr2)

print(newarr)
#+END_SRC

#+RESULTS:
:RESULTS:
(array([ 3,  2,  3,  5, 25,  1]), array([ 1,  6,  3,  0,  0, 27]))
:END:

*** Absolute Values
#+BEGIN_SRC python
import numpy as np

arr = np.array([-1, -2, 1, 2, 3, -4])

newarr = np.absolute(arr)

print(newarr)
#+END_SRC

#+RESULTS:
:RESULTS:
[1 2 1 2 3 4]
:END:

** Rounding Decimals
*** Truncation
- Truncation :: Remove the decimals, and return the float number closest to zero.
#+BEGIN_SRC python
import numpy as np

arr = np.trunc([-3.1666, 3.6667])

print(arr)
#+END_SRC

#+RESULTS:
:RESULTS:
[-3.  3.]
:END:

#+BEGIN_SRC python
import numpy as np

arr = np.fix([-3.1666, 3.6667])

print(arr)
#+END_SRC

#+RESULTS:
:RESULTS:
[-3.  3.]
:END:

*** Rounding
- The around() function increments preceding digit or decimal by 1 if >=5 else do nothing.
#+BEGIN_SRC python
import numpy as np
# Round off 3.1666 to 2 decimal places:
arr = np.around(3.1666, 2)

print(arr)
#+END_SRC

#+RESULTS:
:RESULTS:
3.17
:END:

*** Floor
- The floor() function rounds off decimal to nearest lower integer.
#+BEGIN_SRC python
import numpy as np

arr = np.floor([-3.1666, 3.6667])

print(arr)
#+END_SRC

#+RESULTS:
:RESULTS:
[-4.  3.]
:END:

*** Ceiling
- The ceil() function rounds off decimal to nearest upper integer.
#+BEGIN_SRC python
import numpy as np

arr = np.ceil([-3.1666, 3.6667])

print(arr)
#+END_SRC

#+RESULTS:
:RESULTS:
[-3.  4.]
:END:

** NumPy Logs
*** Log at Base 2
#+BEGIN_SRC python
import numpy as np

arr = np.arange(1, 10)

print(np.log2(arr))
#+END_SRC

#+RESULTS:
:RESULTS:
[0.         1.         1.5849625  2.         2.32192809 2.5849625
 2.80735492 3.         3.169925  ]
:END:

*** Log at Base 10
#+BEGIN_SRC python
import numpy as np

arr = np.arange(1, 10)

print(np.log10(arr))
#+END_SRC

#+RESULTS:
:RESULTS:
[0.         0.30103    0.47712125 0.60205999 0.69897    0.77815125
 0.84509804 0.90308999 0.95424251]
:END:

*** Log at Base e
#+BEGIN_SRC python
import numpy as np

arr = np.arange(1, 10)

print(np.log(arr))
#+END_SRC

#+RESULTS:
:RESULTS:
[0.         0.69314718 1.09861229 1.38629436 1.60943791 1.79175947
 1.94591015 2.07944154 2.19722458]
:END:

*** Log at Any Base
#+BEGIN_SRC python
from math import log
import numpy as np

nplog = np.frompyfunc(log, 2, 1)

print(nplog(100, 15))
#+END_SRC

#+RESULTS:
:RESULTS:
1.7005483074552052
:END:

** NumPy Summations
- Addition is done between two arguments whereas summation happens over n elements.
*** Addition vs Summation
#+BEGIN_SRC python
import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([1, 2, 3])

newarr = np.add(arr1, arr2)

print(newarr)
#+END_SRC

#+RESULTS:
:RESULTS:
[2 4 6]
:END:

#+BEGIN_SRC python
import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([1, 2, 3])

newarr = np.sum([arr1, arr2])

print(newarr)
#+END_SRC

#+RESULTS:
:RESULTS:
12
:END:

*** Summation Over an Axis
- In np.sum(), the axis parameter controls which axis will be aggregated.
- Said differently, the axis parameter controls which axis will be collapsed.

#+BEGIN_SRC python
import numpy as np
# Perform summation in the following array over 1st axis:
arr1 = np.array([[1, 2, 3], [4, 5, 6]])
arr2 = np.array([[7, 8, 9], [10, 11, 12]])

newarr0 = np.sum([arr1, arr2], axis=0)
newarr1 = np.sum([arr1, arr2], axis=1)
newarr2 = np.sum([arr1, arr2], axis=2)

print(arr1)
print(arr2)
print(newarr0)
print(newarr1)
print(newarr2)
#+END_SRC

#+RESULTS:
:RESULTS:
[[1 2 3]
 [4 5 6]]
[[ 7  8  9]
 [10 11 12]]
[[ 8 10 12]
 [14 16 18]]
[[ 5  7  9]
 [17 19 21]]
[[ 6 15]
 [24 33]]
:END:

#+BEGIN_SRC python
import numpy as np

np_array_2d = np.arange(0, 6).reshape([2,3])
print(np_array_2d)
print(np.sum(np_array_2d, axis = 0))
print(np.sum(np_array_2d, axis = 1))
#+END_SRC

#+RESULTS:
:RESULTS:
[[0 1 2]
 [3 4 5]]
[3 5 7]
[ 3 12]
:END:

*** Cummulative Sum
- Cummulative sum :: partially adding the elements in array.
#+BEGIN_SRC python
import numpy as np

arr = np.array([1, 2, 3])

newarr = np.cumsum(arr)

print(newarr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[1 3 6]
:END:
** NumPy Products
#+BEGIN_SRC python
import numpy as np

arr = np.array([1, 2, 3, 4])

x = np.prod(arr)

print(x)
#+END_SRC

#+RESULTS:
:RESULTS:
24
:END:

#+BEGIN_SRC python
import numpy as np

arr1 = np.array([1, 2, 3, 4])
arr2 = np.array([5, 6, 7, 8])

x = np.prod([arr1, arr2])

print(x)
#+END_SRC

#+RESULTS:
:RESULTS:
40320
:END:

#+BEGIN_SRC python
import numpy as np

arr1 = np.array([1, 2, 3, 4])
arr2 = np.array([5, 6, 7, 8])

newarr = np.prod([arr1, arr2], axis=1)

print(newarr)
#+END_SRC

#+RESULTS:
:RESULTS:
[  24 1680]
:END:

#+BEGIN_SRC python
import numpy as np

arr = np.array([5, 6, 7, 8])

newarr = np.cumprod(arr)

print(newarr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[   5   30  210 1680]
:END:

** NumPy Differences
- Discrete difference :: means subtracting two successive elements. E.g. for [1, 2, 3, 4], the discrete difference would be [2-1, 3-2, 4-3] = [1, 1, 1].

#+BEGIN_SRC python
import numpy as np

arr = np.array([10, 15, 25, 5])

newarr = np.diff(arr)

print(newarr)
#+END_SRC

#+RESULTS:
:RESULTS:
[  5  10 -20]
:END:

#+BEGIN_SRC python
import numpy as np
# Compute discrete difference of the following array twice:
arr = np.array([10, 15, 25, 5])

newarr = np.diff(arr, n=2)

print(newarr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[  5 -30]
:END:

** NumPy LCM Lowest Common Multiple
- Lowest Common Multiple :: the smallest number that is a common multiple of two numbers.

#+BEGIN_SRC python
import numpy as np

num1 = 4
num2 = 6

x = np.lcm(num1, num2)

print(x)
#+END_SRC

#+RESULTS:
:RESULTS:
12
:END:

#+BEGIN_SRC python
import numpy as np

arr = np.array([3, 6, 9])

x = np.lcm.reduce(arr)

print(x)
#+END_SRC

#+RESULTS:
:RESULTS:
18
:END:

#+BEGIN_SRC python
import numpy as np

arr = np.arange(1, 11)

x = np.lcm.reduce(arr)

print(x)
#+END_SRC

#+RESULTS:
:RESULTS:
2520
:END:

** NumPy GCD Greatest Common Denominator
- GCD (Greatest Common Denominator) :: also known as HCF (Highest Common Factor) is the biggest number that is a common factor of both of the numbers.

#+BEGIN_SRC python
import numpy as np

num1 = 6
num2 = 9

x = np.gcd(num1, num2)

print(x)
#+END_SRC

#+RESULTS:
:RESULTS:
3
:END:

#+BEGIN_SRC python
import numpy as np

arr = np.array([20, 8, 32, 36, 16])

x = np.gcd.reduce(arr)

print(x)
#+END_SRC

#+RESULTS:
:RESULTS:
4
:END:

** NumPy Trigonometric Functions
*** Trigonometric Functions
- Values in radian.

#+BEGIN_SRC python
import numpy as np

x = np.sin(np.pi/2)

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
1.0
:END:

#+BEGIN_SRC python
import numpy as np

arr = np.array([np.pi/2, np.pi/3, np.pi/4, np.pi/5])

x = np.sin(arr)

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[1.         0.8660254  0.70710678 0.58778525]
:END:

*** Convert Degrees Into Radians
- radians values are pi/180 * degree_values.

#+BEGIN_SRC python
import numpy as np

arr = np.array([90, 180, 270, 360])

x = np.deg2rad(arr)

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[1.57079633 3.14159265 4.71238898 6.28318531]
:END:

*** Radians to Degrees
#+BEGIN_SRC python
import numpy as np

arr = np.array([np.pi/2, np.pi, 1.5*np.pi, 2*np.pi])

x = np.rad2deg(arr)

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[ 90. 180. 270. 360.]
:END:

*** Finding Angles
#+BEGIN_SRC python
import numpy as np

x = np.arcsin(1.0)

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
1.5707963267948966
:END:

#+BEGIN_SRC python
import numpy as np

arr = np.array([1, -1, 0.1])

x = np.arcsin(arr)

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[ 1.57079633 -1.57079633  0.10016742]
:END:

*** Hupotenues
- Finding hypotenues using pythagoras theorem in NumPy.

#+BEGIN_SRC python
import numpy as np

base = 3
perp = 4

x = np.hypot(base, perp)

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
5.0
:END:

** NumPy Hyperbolic Functions
*** Hyperbolic Functions
#+BEGIN_SRC python
import numpy as np

x = np.sinh(np.pi/2)

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
2.3012989023072947
:END:

#+BEGIN_SRC python
import numpy as np

arr = np.array([np.pi/2, np.pi/3, np.pi/4, np.pi/5])

x = np.cosh(arr)

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[2.50917848 1.60028686 1.32460909 1.20397209]
:END:

*** Finding Angles
#+BEGIN_SRC python
import numpy as np

x = np.arcsinh(1.0)

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
0.881373587019543
:END:

#+BEGIN_SRC python
import numpy as np

arr = np.array([0.1, 0.2, 0.5])

x = np.arctanh(arr)

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[0.10033535 0.20273255 0.54930614]
:END:

** NumPy Set Operations
*** Set
- Set :: a collection of unique elements.
- Sets are used for operations involving frequent intersection, union and difference operations.

#+BEGIN_SRC python
import numpy as np

arr = np.array([1, 1, 1, 2, 3, 4, 5, 5, 6, 7])

x = np.unique(arr)

print(x) 
#+END_SRC

#+RESULTS:
:RESULTS:
[1 2 3 4 5 6 7]
:END:

*** Union
#+BEGIN_SRC python
import numpy as np

arr1 = np.array([1, 2, 3, 4])
arr2 = np.array([3, 4, 5, 6])

newarr = np.union1d(arr1, arr2)

print(newarr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[1 2 3 4 5 6]
:END:

*** Intersection
#+BEGIN_SRC python
import numpy as np

arr1 = np.array([1, 2, 3, 4])
arr2 = np.array([3, 4, 5, 6])

newarr = np.intersect1d(arr1, arr2, assume_unique=True)

print(newarr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[3 4]
:END:

*** Difference
#+BEGIN_SRC python
import numpy as np

set1 = np.array([1, 2, 3, 4])
set2 = np.array([3, 4, 5, 6])

newarr = np.setdiff1d(set1, set2, assume_unique=True)

print(newarr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[1 2]
:END:

*** Symmetric Difference
#+BEGIN_SRC python
import numpy as np

set1 = np.array([1, 2, 3, 4])
set2 = np.array([3, 4, 5, 6])

newarr = np.setxor1d(set1, set2, assume_unique=True)

print(newarr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[1 2 5 6]
:END:

* Pandas
- Pandas :: a Python library used for working with data sets. It has functions for analyzing, cleaning, exploring, and manipulating data.
- Pandas allows us to analyze big data and make conclusions based on statistical theories.
- Pandas can clean messy data sets, and make them readable and relevant. Relevant data is very important in data science.
- Data Science :: a branch of computer science where we study how to store, use and analyze data for deriving information from it.
*** Version
#+BEGIN_SRC python
import pandas as pd

print(pd.__version__) 
#+END_SRC

#+RESULTS:
:RESULTS:
2.1.0
:END:
*** Pandas Series
- Pandas Series :: like a column in a table. It is a one-dimensional array holding data of any type.
#+BEGIN_SRC python
import pandas as pd

a = [1, 7, 2]

myvar = pd.Series(a, index = ["x", "y", "z"])

print(myvar)
#+END_SRC

#+RESULTS:
:RESULTS:
x    1
y    7
z    2
dtype: int64
:END:
#+BEGIN_SRC python
import pandas as pd

calories = {"day1": 420, "day2": 380, "day3": 390}

myvar = pd.Series(calories, index = ["day1", "day2"])

print(myvar)
#+END_SRC

#+RESULTS:
:RESULTS:
day1    420
day2    380
dtype: int64
:END:

*** Pandas DataFrames
- Pandas DataFrames :: a 2 dimensional data structure, like a 2 dimensional array, or a table with rows and columns.
#+BEGIN_SRC python
import pandas as pd

data = {
  "calories": [420, 380, 390],
  "duration": [50, 40, 45]
}

#load data into a DataFrame object:
df = pd.DataFrame(data)

print(df)
#refer to the row index:
print(df.loc[0])
#use a list of indexes:
print(df.loc[[0, 1]])
#+END_SRC

#+RESULTS:
:RESULTS:
   calories  duration
0       420        50
1       380        40
2       390        45
calories    420
duration     50
Name: 0, dtype: int64
   calories  duration
0       420        50
1       380        40
:END:
#+BEGIN_SRC python
import pandas as pd

data = {
  "calories": [420, 380, 390],
  "duration": [50, 40, 45]
}

df = pd.DataFrame(data, index = ["day1", "day2", "day3"])

print(df)
#refer to the named index:
print(df.loc["day2"])
#+END_SRC

#+RESULTS:
:RESULTS:
      calories  duration
day1       420        50
day2       380        40
day3       390        45
calories    380
duration     40
Name: day2, dtype: int64
:END:

*** Pandas Read CSV
#+BEGIN_SRC python
import pandas as pd
# use to_string() to print the entire DataFrame.
df = pd.read_csv('data.csv')

print(df.to_string())
#+END_SRC

#+RESULTS:
:RESULTS:
     Duration  Pulse  Maxpulse  Calories
0          60    110       130     409.1
1          60    117       145     479.0
2          60    103       135     340.0
3          45    109       175     282.4
4          45    117       148     406.0
5          60    102       127     300.0
6          60    110       136     374.0
7          45    104       134     253.3
8          30    109       133     195.1
9          60     98       124     269.0
10         60    103       147     329.3
11         60    100       120     250.7
12         60    106       128     345.3
13         60    104       132     379.3
14         60     98       123     275.0
15         60     98       120     215.2
16         60    100       120     300.0
17         45     90       112       NaN
18         60    103       123     323.0
19         45     97       125     243.0
20         60    108       131     364.2
21         45    100       119     282.0
22         60    130       101     300.0
23         45    105       132     246.0
24         60    102       126     334.5
25         60    100       120     250.0
26         60     92       118     241.0
27         60    103       132       NaN
28         60    100       132     280.0
29         60    102       129     380.3
30         60     92       115     243.0
31         45     90       112     180.1
32         60    101       124     299.0
33         60     93       113     223.0
34         60    107       136     361.0
35         60    114       140     415.0
36         60    102       127     300.0
37         60    100       120     300.0
38         60    100       120     300.0
39         45    104       129     266.0
40         45     90       112     180.1
41         60     98       126     286.0
42         60    100       122     329.4
43         60    111       138     400.0
44         60    111       131     397.0
45         60     99       119     273.0
46         60    109       153     387.6
47         45    111       136     300.0
48         45    108       129     298.0
49         60    111       139     397.6
50         60    107       136     380.2
51         80    123       146     643.1
52         60    106       130     263.0
53         60    118       151     486.0
54         30    136       175     238.0
55         60    121       146     450.7
56         60    118       121     413.0
57         45    115       144     305.0
58         20    153       172     226.4
59         45    123       152     321.0
60        210    108       160    1376.0
61        160    110       137    1034.4
62        160    109       135     853.0
63         45    118       141     341.0
64         20    110       130     131.4
65        180     90       130     800.4
66        150    105       135     873.4
67        150    107       130     816.0
68         20    106       136     110.4
69        300    108       143    1500.2
70        150     97       129    1115.0
71         60    109       153     387.6
72         90    100       127     700.0
73        150     97       127     953.2
74         45    114       146     304.0
75         90     98       125     563.2
76         45    105       134     251.0
77         45    110       141     300.0
78        120    100       130     500.4
79        270    100       131    1729.0
80         30    159       182     319.2
81         45    149       169     344.0
82         30    103       139     151.1
83        120    100       130     500.0
84         45    100       120     225.3
85         30    151       170     300.0
86         45    102       136     234.0
87        120    100       157    1000.1
88         45    129       103     242.0
89         20     83       107      50.3
90        180    101       127     600.1
91         45    107       137       NaN
92         30     90       107     105.3
93         15     80       100      50.5
94         20    150       171     127.4
95         20    151       168     229.4
96         30     95       128     128.2
97         25    152       168     244.2
98         30    109       131     188.2
99         90     93       124     604.1
100        20     95       112      77.7
101        90     90       110     500.0
102        90     90       100     500.0
103        90     90       100     500.4
104        30     92       108      92.7
105        30     93       128     124.0
106       180     90       120     800.3
107        30     90       120      86.2
108        90     90       120     500.3
109       210    137       184    1860.4
110        60    102       124     325.2
111        45    107       124     275.0
112        15    124       139     124.2
113        45    100       120     225.3
114        60    108       131     367.6
115        60    108       151     351.7
116        60    116       141     443.0
117        60     97       122     277.4
118        60    105       125       NaN
119        60    103       124     332.7
120        30    112       137     193.9
121        45    100       120     100.7
122        60    119       169     336.7
123        60    107       127     344.9
124        60    111       151     368.5
125        60     98       122     271.0
126        60     97       124     275.3
127        60    109       127     382.0
128        90     99       125     466.4
129        60    114       151     384.0
130        60    104       134     342.5
131        60    107       138     357.5
132        60    103       133     335.0
133        60    106       132     327.5
134        60    103       136     339.0
135        20    136       156     189.0
136        45    117       143     317.7
137        45    115       137     318.0
138        45    113       138     308.0
139        20    141       162     222.4
140        60    108       135     390.0
141        60     97       127       NaN
142        45    100       120     250.4
143        45    122       149     335.4
144        60    136       170     470.2
145        45    106       126     270.8
146        60    107       136     400.0
147        60    112       146     361.9
148        30    103       127     185.0
149        60    110       150     409.4
150        60    106       134     343.0
151        60    109       129     353.2
152        60    109       138     374.0
153        30    150       167     275.8
154        60    105       128     328.0
155        60    111       151     368.5
156        60     97       131     270.4
157        60    100       120     270.4
158        60    114       150     382.8
159        30     80       120     240.9
160        30     85       120     250.4
161        45     90       130     260.4
162        45     95       130     270.0
163        45    100       140     280.9
164        60    105       140     290.8
165        60    110       145     300.0
166        60    115       145     310.2
167        75    120       150     320.4
168        75    125       150     330.4
:END:
#+BEGIN_SRC python
import pandas as pd
# Print the DataFrame without the to_string() method:
df = pd.read_csv('data.csv')

print(df) 
#+END_SRC

#+RESULTS:
:RESULTS:
     Duration  Pulse  Maxpulse  Calories
0          60    110       130     409.1
1          60    117       145     479.0
2          60    103       135     340.0
3          45    109       175     282.4
4          45    117       148     406.0
..        ...    ...       ...       ...
164        60    105       140     290.8
165        60    110       145     300.0
166        60    115       145     310.2
167        75    120       150     320.4
168        75    125       150     330.4

[169 rows x 4 columns]
:END:
#+BEGIN_SRC python
import pandas as pd
# Check the number of maximum returned rows:
print(pd.options.display.max_rows) 
#+END_SRC

#+RESULTS:
:RESULTS:
60
:END:

*** Pandas Read JSON
- JSON :: JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax.
- JSON = Python Dictionary. JSON objects have the same format as Python dictionaries.

#+BEGIN_SRC python
import pandas as pd

df = pd.read_json('data.json')

print(df.to_string()) 
#+END_SRC

#+RESULTS:
:RESULTS:
     Duration  Pulse  Maxpulse  Calories
0          60    110       130     409.1
1          60    117       145     479.0
2          60    103       135     340.0
3          45    109       175     282.4
4          45    117       148     406.0
5          60    102       127     300.5
6          60    110       136     374.0
7          45    104       134     253.3
8          30    109       133     195.1
9          60     98       124     269.0
10         60    103       147     329.3
11         60    100       120     250.7
12         60    106       128     345.3
13         60    104       132     379.3
14         60     98       123     275.0
15         60     98       120     215.2
16         60    100       120     300.0
17         45     90       112       NaN
18         60    103       123     323.0
19         45     97       125     243.0
20         60    108       131     364.2
21         45    100       119     282.0
22         60    130       101     300.0
23         45    105       132     246.0
24         60    102       126     334.5
25         60    100       120     250.0
26         60     92       118     241.0
27         60    103       132       NaN
28         60    100       132     280.0
29         60    102       129     380.3
30         60     92       115     243.0
31         45     90       112     180.1
32         60    101       124     299.0
33         60     93       113     223.0
34         60    107       136     361.0
35         60    114       140     415.0
36         60    102       127     300.5
37         60    100       120     300.1
38         60    100       120     300.0
39         45    104       129     266.0
40         45     90       112     180.1
41         60     98       126     286.0
42         60    100       122     329.4
43         60    111       138     400.0
44         60    111       131     397.0
45         60     99       119     273.0
46         60    109       153     387.6
47         45    111       136     300.0
48         45    108       129     298.0
49         60    111       139     397.6
50         60    107       136     380.2
51         80    123       146     643.1
52         60    106       130     263.0
53         60    118       151     486.0
54         30    136       175     238.0
55         60    121       146     450.7
56         60    118       121     413.0
57         45    115       144     305.0
58         20    153       172     226.4
59         45    123       152     321.0
60        210    108       160    1376.0
61        160    110       137    1034.4
62        160    109       135     853.0
63         45    118       141     341.0
64         20    110       130     131.4
65        180     90       130     800.4
66        150    105       135     873.4
67        150    107       130     816.0
68         20    106       136     110.4
69        300    108       143    1500.2
70        150     97       129    1115.0
71         60    109       153     387.6
72         90    100       127     700.0
73        150     97       127     953.2
74         45    114       146     304.0
75         90     98       125     563.2
76         45    105       134     251.0
77         45    110       141     300.0
78        120    100       130     500.4
79        270    100       131    1729.0
80         30    159       182     319.2
81         45    149       169     344.0
82         30    103       139     151.1
83        120    100       130     500.0
84         45    100       120     225.3
85         30    151       170     300.1
86         45    102       136     234.0
87        120    100       157    1000.1
88         45    129       103     242.0
89         20     83       107      50.3
90        180    101       127     600.1
91         45    107       137       NaN
92         30     90       107     105.3
93         15     80       100      50.5
94         20    150       171     127.4
95         20    151       168     229.4
96         30     95       128     128.2
97         25    152       168     244.2
98         30    109       131     188.2
99         90     93       124     604.1
100        20     95       112      77.7
101        90     90       110     500.0
102        90     90       100     500.0
103        90     90       100     500.4
104        30     92       108      92.7
105        30     93       128     124.0
106       180     90       120     800.3
107        30     90       120      86.2
108        90     90       120     500.3
109       210    137       184    1860.4
110        60    102       124     325.2
111        45    107       124     275.0
112        15    124       139     124.2
113        45    100       120     225.3
114        60    108       131     367.6
115        60    108       151     351.7
116        60    116       141     443.0
117        60     97       122     277.4
118        60    105       125       NaN
119        60    103       124     332.7
120        30    112       137     193.9
121        45    100       120     100.7
122        60    119       169     336.7
123        60    107       127     344.9
124        60    111       151     368.5
125        60     98       122     271.0
126        60     97       124     275.3
127        60    109       127     382.0
128        90     99       125     466.4
129        60    114       151     384.0
130        60    104       134     342.5
131        60    107       138     357.5
132        60    103       133     335.0
133        60    106       132     327.5
134        60    103       136     339.0
135        20    136       156     189.0
136        45    117       143     317.7
137        45    115       137     318.0
138        45    113       138     308.0
139        20    141       162     222.4
140        60    108       135     390.0
141        60     97       127       NaN
142        45    100       120     250.4
143        45    122       149     335.4
144        60    136       170     470.2
145        45    106       126     270.8
146        60    107       136     400.0
147        60    112       146     361.9
148        30    103       127     185.0
149        60    110       150     409.4
150        60    106       134     343.0
151        60    109       129     353.2
152        60    109       138     374.0
153        30    150       167     275.8
154        60    105       128     328.0
155        60    111       151     368.5
156        60     97       131     270.4
157        60    100       120     270.4
158        60    114       150     382.8
159        30     80       120     240.9
160        30     85       120     250.4
161        45     90       130     260.4
162        45     95       130     270.0
163        45    100       140     280.9
164        60    105       140     290.8
165        60    110       145     300.4
166        60    115       145     310.2
167        75    120       150     320.4
168        75    125       150     330.4
:END:
#+BEGIN_SRC python
import pandas as pd

data = {
  "Duration":{
    "0":60,
    "1":60,
    "2":60,
    "3":45,
    "4":45,
    "5":60
  },
  "Pulse":{
    "0":110,
    "1":117,
    "2":103,
    "3":109,
    "4":117,
    "5":102
  },
  "Maxpulse":{
    "0":130,
    "1":145,
    "2":135,
    "3":175,
    "4":148,
    "5":127
  },
  "Calories":{
    "0":409,
    "1":479,
    "2":340,
    "3":282,
    "4":406,
    "5":300
  }
}

df = pd.DataFrame(data)

print(df) 
#+END_SRC

#+RESULTS:
:RESULTS:
   Duration  Pulse  Maxpulse  Calories
0        60    110       130       409
1        60    117       145       479
2        60    103       135       340
3        45    109       175       282
4        45    117       148       406
5        60    102       127       300
:END:

*** Analyzing DataFrames
#+BEGIN_SRC python
import pandas as pd
# Get a quick overview by printing the first 10 rows of the DataFrame:
df = pd.read_csv('data.csv')

print(df.head(10))
print(df.head())
print(df.tail())
print(df.info())
#+END_SRC

#+RESULTS:
:RESULTS:
   Duration  Pulse  Maxpulse  Calories
0        60    110       130     409.1
1        60    117       145     479.0
2        60    103       135     340.0
3        45    109       175     282.4
4        45    117       148     406.0
5        60    102       127     300.0
6        60    110       136     374.0
7        45    104       134     253.3
8        30    109       133     195.1
9        60     98       124     269.0
   Duration  Pulse  Maxpulse  Calories
0        60    110       130     409.1
1        60    117       145     479.0
2        60    103       135     340.0
3        45    109       175     282.4
4        45    117       148     406.0
     Duration  Pulse  Maxpulse  Calories
164        60    105       140     290.8
165        60    110       145     300.0
166        60    115       145     310.2
167        75    120       150     320.4
168        75    125       150     330.4
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 169 entries, 0 to 168
Data columns (total 4 columns):
 #   Column    Non-Null Count  Dtype  
---  ------    --------------  -----  
 0   Duration  169 non-null    int64  
 1   Pulse     169 non-null    int64  
 2   Maxpulse  169 non-null    int64  
 3   Calories  164 non-null    float64
dtypes: float64(1), int64(3)
memory usage: 5.4 KB
None
:END:

*** Cleaning Data
- Data cleaning :: fixing bad data in your data set.
- Bad data :: Bad data could be:
    - Empty cells
    - Data in wrong format
    - Wrong data
    - Duplicates
*** Cleaning Empty Cells
- One way to deal with empty cells is to remove rows that contain empty cells.
- This is usually OK, since data sets can be very big, and removing a few rows will not have a big impact on the result.
#+BEGIN_SRC python
import pandas as pd
# Return a new Data Frame with no empty cells:
df = pd.read_csv('data1.csv')

new_df = df.dropna() # By default, the dropna() method returns a new DataFrame, and will not change the original.

print(new_df.to_string())
#+END_SRC

#+RESULTS:
:RESULTS:
    SN  Duration          Date  Pulse  Maxpulse  Calories
0    0        60  '2020/12/01'    110       130     409.1
1    1        60  '2020/12/02'    117       145     479.0
2    2        60  '2020/12/03'    103       135     340.0
3    3        45  '2020/12/04'    109       175     282.4
4    4        45  '2020/12/05'    117       148     406.0
5    5        60  '2020/12/06'    102       127     300.0
6    6        60  '2020/12/07'    110       136     374.0
7    7       450  '2020/12/08'    104       134     253.3
8    8        30  '2020/12/09'    109       133     195.1
9    9        60  '2020/12/10'     98       124     269.0
10  10        60  '2020/12/11'    103       147     329.3
11  11        60  '2020/12/12'    100       120     250.7
12  12        60  '2020/12/12'    100       120     250.7
13  13        60  '2020/12/13'    106       128     345.3
14  14        60  '2020/12/14'    104       132     379.3
15  15        60  '2020/12/15'     98       123     275.0
16  16        60  '2020/12/16'     98       120     215.2
17  17        60  '2020/12/17'    100       120     300.0
19  19        60  '2020/12/19'    103       123     323.0
20  20        45  '2020/12/20'     97       125     243.0
21  21        60  '2020/12/21'    108       131     364.2
23  23        60  '2020/12/23'    130       101     300.0
24  24        45  '2020/12/24'    105       132     246.0
25  25        60  '2020/12/25'    102       126     334.5
26  26        60    2020/12/26    100       120     250.0
27  27        60  '2020/12/27'     92       118     241.0
29  29        60  '2020/12/29'    100       132     280.0
30  30        60  '2020/12/30'    102       129     380.3
31  31        60  '2020/12/31'     92       115     243.0
:END:
#+BEGIN_SRC python
import pandas as pd

df = pd.read_csv('data.csv')

df.dropna(inplace = True) # If you want to change the original DataFrame, use the inplace = True argument:

print(df.to_string()) 
#+END_SRC

#+RESULTS:
:RESULTS:
     Duration  Pulse  Maxpulse  Calories
0          60    110       130     409.1
1          60    117       145     479.0
2          60    103       135     340.0
3          45    109       175     282.4
4          45    117       148     406.0
5          60    102       127     300.0
6          60    110       136     374.0
7          45    104       134     253.3
8          30    109       133     195.1
9          60     98       124     269.0
10         60    103       147     329.3
11         60    100       120     250.7
12         60    106       128     345.3
13         60    104       132     379.3
14         60     98       123     275.0
15         60     98       120     215.2
16         60    100       120     300.0
18         60    103       123     323.0
19         45     97       125     243.0
20         60    108       131     364.2
21         45    100       119     282.0
22         60    130       101     300.0
23         45    105       132     246.0
24         60    102       126     334.5
25         60    100       120     250.0
26         60     92       118     241.0
28         60    100       132     280.0
29         60    102       129     380.3
30         60     92       115     243.0
31         45     90       112     180.1
32         60    101       124     299.0
33         60     93       113     223.0
34         60    107       136     361.0
35         60    114       140     415.0
36         60    102       127     300.0
37         60    100       120     300.0
38         60    100       120     300.0
39         45    104       129     266.0
40         45     90       112     180.1
41         60     98       126     286.0
42         60    100       122     329.4
43         60    111       138     400.0
44         60    111       131     397.0
45         60     99       119     273.0
46         60    109       153     387.6
47         45    111       136     300.0
48         45    108       129     298.0
49         60    111       139     397.6
50         60    107       136     380.2
51         80    123       146     643.1
52         60    106       130     263.0
53         60    118       151     486.0
54         30    136       175     238.0
55         60    121       146     450.7
56         60    118       121     413.0
57         45    115       144     305.0
58         20    153       172     226.4
59         45    123       152     321.0
60        210    108       160    1376.0
61        160    110       137    1034.4
62        160    109       135     853.0
63         45    118       141     341.0
64         20    110       130     131.4
65        180     90       130     800.4
66        150    105       135     873.4
67        150    107       130     816.0
68         20    106       136     110.4
69        300    108       143    1500.2
70        150     97       129    1115.0
71         60    109       153     387.6
72         90    100       127     700.0
73        150     97       127     953.2
74         45    114       146     304.0
75         90     98       125     563.2
76         45    105       134     251.0
77         45    110       141     300.0
78        120    100       130     500.4
79        270    100       131    1729.0
80         30    159       182     319.2
81         45    149       169     344.0
82         30    103       139     151.1
83        120    100       130     500.0
84         45    100       120     225.3
85         30    151       170     300.0
86         45    102       136     234.0
87        120    100       157    1000.1
88         45    129       103     242.0
89         20     83       107      50.3
90        180    101       127     600.1
92         30     90       107     105.3
93         15     80       100      50.5
94         20    150       171     127.4
95         20    151       168     229.4
96         30     95       128     128.2
97         25    152       168     244.2
98         30    109       131     188.2
99         90     93       124     604.1
100        20     95       112      77.7
101        90     90       110     500.0
102        90     90       100     500.0
103        90     90       100     500.4
104        30     92       108      92.7
105        30     93       128     124.0
106       180     90       120     800.3
107        30     90       120      86.2
108        90     90       120     500.3
109       210    137       184    1860.4
110        60    102       124     325.2
111        45    107       124     275.0
112        15    124       139     124.2
113        45    100       120     225.3
114        60    108       131     367.6
115        60    108       151     351.7
116        60    116       141     443.0
117        60     97       122     277.4
119        60    103       124     332.7
120        30    112       137     193.9
121        45    100       120     100.7
122        60    119       169     336.7
123        60    107       127     344.9
124        60    111       151     368.5
125        60     98       122     271.0
126        60     97       124     275.3
127        60    109       127     382.0
128        90     99       125     466.4
129        60    114       151     384.0
130        60    104       134     342.5
131        60    107       138     357.5
132        60    103       133     335.0
133        60    106       132     327.5
134        60    103       136     339.0
135        20    136       156     189.0
136        45    117       143     317.7
137        45    115       137     318.0
138        45    113       138     308.0
139        20    141       162     222.4
140        60    108       135     390.0
142        45    100       120     250.4
143        45    122       149     335.4
144        60    136       170     470.2
145        45    106       126     270.8
146        60    107       136     400.0
147        60    112       146     361.9
148        30    103       127     185.0
149        60    110       150     409.4
150        60    106       134     343.0
151        60    109       129     353.2
152        60    109       138     374.0
153        30    150       167     275.8
154        60    105       128     328.0
155        60    111       151     368.5
156        60     97       131     270.4
157        60    100       120     270.4
158        60    114       150     382.8
159        30     80       120     240.9
160        30     85       120     250.4
161        45     90       130     260.4
162        45     95       130     270.0
163        45    100       140     280.9
164        60    105       140     290.8
165        60    110       145     300.0
166        60    115       145     310.2
167        75    120       150     320.4
168        75    125       150     330.4
:END:
#+BEGIN_SRC python
import pandas as pd
# Replace NULL values with the number 130:
df = pd.read_csv('data1.csv')

df.fillna(130, inplace = True)

print(df.to_string())
#+END_SRC

#+RESULTS:
:RESULTS:
    SN  Duration          Date  Pulse  Maxpulse  Calories
0    0        60  '2020/12/01'    110       130     409.1
1    1        60  '2020/12/02'    117       145     479.0
2    2        60  '2020/12/03'    103       135     340.0
3    3        45  '2020/12/04'    109       175     282.4
4    4        45  '2020/12/05'    117       148     406.0
5    5        60  '2020/12/06'    102       127     300.0
6    6        60  '2020/12/07'    110       136     374.0
7    7       450  '2020/12/08'    104       134     253.3
8    8        30  '2020/12/09'    109       133     195.1
9    9        60  '2020/12/10'     98       124     269.0
10  10        60  '2020/12/11'    103       147     329.3
11  11        60  '2020/12/12'    100       120     250.7
12  12        60  '2020/12/12'    100       120     250.7
13  13        60  '2020/12/13'    106       128     345.3
14  14        60  '2020/12/14'    104       132     379.3
15  15        60  '2020/12/15'     98       123     275.0
16  16        60  '2020/12/16'     98       120     215.2
17  17        60  '2020/12/17'    100       120     300.0
18  18        45  '2020/12/18'     90       112     130.0
19  19        60  '2020/12/19'    103       123     323.0
20  20        45  '2020/12/20'     97       125     243.0
21  21        60  '2020/12/21'    108       131     364.2
22  22        45           130    100       119     282.0
23  23        60  '2020/12/23'    130       101     300.0
24  24        45  '2020/12/24'    105       132     246.0
25  25        60  '2020/12/25'    102       126     334.5
26  26        60    2020/12/26    100       120     250.0
27  27        60  '2020/12/27'     92       118     241.0
28  28        60  '2020/12/28'    103       132     130.0
29  29        60  '2020/12/29'    100       132     280.0
30  30        60  '2020/12/30'    102       129     380.3
31  31        60  '2020/12/31'     92       115     243.0
:END:
#+BEGIN_SRC python
import pandas as pd
# Replace NULL values in the "Calories" columns with the number 130:
df = pd.read_csv('data1.csv')

df["Calories"].fillna(130, inplace = True)

print(df.to_string())
#+END_SRC

#+RESULTS:
:RESULTS:
    SN  Duration          Date  Pulse  Maxpulse  Calories
0    0        60  '2020/12/01'    110       130     409.1
1    1        60  '2020/12/02'    117       145     479.0
2    2        60  '2020/12/03'    103       135     340.0
3    3        45  '2020/12/04'    109       175     282.4
4    4        45  '2020/12/05'    117       148     406.0
5    5        60  '2020/12/06'    102       127     300.0
6    6        60  '2020/12/07'    110       136     374.0
7    7       450  '2020/12/08'    104       134     253.3
8    8        30  '2020/12/09'    109       133     195.1
9    9        60  '2020/12/10'     98       124     269.0
10  10        60  '2020/12/11'    103       147     329.3
11  11        60  '2020/12/12'    100       120     250.7
12  12        60  '2020/12/12'    100       120     250.7
13  13        60  '2020/12/13'    106       128     345.3
14  14        60  '2020/12/14'    104       132     379.3
15  15        60  '2020/12/15'     98       123     275.0
16  16        60  '2020/12/16'     98       120     215.2
17  17        60  '2020/12/17'    100       120     300.0
18  18        45  '2020/12/18'     90       112     130.0
19  19        60  '2020/12/19'    103       123     323.0
20  20        45  '2020/12/20'     97       125     243.0
21  21        60  '2020/12/21'    108       131     364.2
22  22        45           NaN    100       119     282.0
23  23        60  '2020/12/23'    130       101     300.0
24  24        45  '2020/12/24'    105       132     246.0
25  25        60  '2020/12/25'    102       126     334.5
26  26        60    2020/12/26    100       120     250.0
27  27        60  '2020/12/27'     92       118     241.0
28  28        60  '2020/12/28'    103       132     130.0
29  29        60  '2020/12/29'    100       132     280.0
30  30        60  '2020/12/30'    102       129     380.3
31  31        60  '2020/12/31'     92       115     243.0
:END:
#+BEGIN_SRC python
import pandas as pd
# Calculate the MEAN, and replace any empty values with it:
df = pd.read_csv('data1.csv')

x = df["Calories"].mean()

df["Calories"].fillna(x, inplace = True)

print(df.to_string()) 
#+END_SRC

#+RESULTS:
:RESULTS:
    SN  Duration          Date  Pulse  Maxpulse  Calories
0    0        60  '2020/12/01'    110       130    409.10
1    1        60  '2020/12/02'    117       145    479.00
2    2        60  '2020/12/03'    103       135    340.00
3    3        45  '2020/12/04'    109       175    282.40
4    4        45  '2020/12/05'    117       148    406.00
5    5        60  '2020/12/06'    102       127    300.00
6    6        60  '2020/12/07'    110       136    374.00
7    7       450  '2020/12/08'    104       134    253.30
8    8        30  '2020/12/09'    109       133    195.10
9    9        60  '2020/12/10'     98       124    269.00
10  10        60  '2020/12/11'    103       147    329.30
11  11        60  '2020/12/12'    100       120    250.70
12  12        60  '2020/12/12'    100       120    250.70
13  13        60  '2020/12/13'    106       128    345.30
14  14        60  '2020/12/14'    104       132    379.30
15  15        60  '2020/12/15'     98       123    275.00
16  16        60  '2020/12/16'     98       120    215.20
17  17        60  '2020/12/17'    100       120    300.00
18  18        45  '2020/12/18'     90       112    304.68
19  19        60  '2020/12/19'    103       123    323.00
20  20        45  '2020/12/20'     97       125    243.00
21  21        60  '2020/12/21'    108       131    364.20
22  22        45           NaN    100       119    282.00
23  23        60  '2020/12/23'    130       101    300.00
24  24        45  '2020/12/24'    105       132    246.00
25  25        60  '2020/12/25'    102       126    334.50
26  26        60    2020/12/26    100       120    250.00
27  27        60  '2020/12/27'     92       118    241.00
28  28        60  '2020/12/28'    103       132    304.68
29  29        60  '2020/12/29'    100       132    280.00
30  30        60  '2020/12/30'    102       129    380.30
31  31        60  '2020/12/31'     92       115    243.00
:END:
#+BEGIN_SRC python
import pandas as pd
# Calculate the MEDIAN, and replace any empty values with it:
df = pd.read_csv('data1.csv')

x = df["Calories"].median()

df["Calories"].fillna(x, inplace = True)

print(df.to_string()) 
#+END_SRC

#+RESULTS:
:RESULTS:
    SN  Duration          Date  Pulse  Maxpulse  Calories
0    0        60  '2020/12/01'    110       130     409.1
1    1        60  '2020/12/02'    117       145     479.0
2    2        60  '2020/12/03'    103       135     340.0
3    3        45  '2020/12/04'    109       175     282.4
4    4        45  '2020/12/05'    117       148     406.0
5    5        60  '2020/12/06'    102       127     300.0
6    6        60  '2020/12/07'    110       136     374.0
7    7       450  '2020/12/08'    104       134     253.3
8    8        30  '2020/12/09'    109       133     195.1
9    9        60  '2020/12/10'     98       124     269.0
10  10        60  '2020/12/11'    103       147     329.3
11  11        60  '2020/12/12'    100       120     250.7
12  12        60  '2020/12/12'    100       120     250.7
13  13        60  '2020/12/13'    106       128     345.3
14  14        60  '2020/12/14'    104       132     379.3
15  15        60  '2020/12/15'     98       123     275.0
16  16        60  '2020/12/16'     98       120     215.2
17  17        60  '2020/12/17'    100       120     300.0
18  18        45  '2020/12/18'     90       112     291.2
19  19        60  '2020/12/19'    103       123     323.0
20  20        45  '2020/12/20'     97       125     243.0
21  21        60  '2020/12/21'    108       131     364.2
22  22        45           NaN    100       119     282.0
23  23        60  '2020/12/23'    130       101     300.0
24  24        45  '2020/12/24'    105       132     246.0
25  25        60  '2020/12/25'    102       126     334.5
26  26        60    2020/12/26    100       120     250.0
27  27        60  '2020/12/27'     92       118     241.0
28  28        60  '2020/12/28'    103       132     291.2
29  29        60  '2020/12/29'    100       132     280.0
30  30        60  '2020/12/30'    102       129     380.3
31  31        60  '2020/12/31'     92       115     243.0
:END:
#+BEGIN_SRC python
import pandas as pd
# Calculate the MODE, and replace any empty values with it:
df = pd.read_csv('data.csv')

x = df["Calories"].mode()[0]

df["Calories"].fillna(x, inplace = True)

print(df.to_string()) 
#+END_SRC

#+RESULTS:
:RESULTS:
     Duration  Pulse  Maxpulse  Calories
0          60    110       130     409.1
1          60    117       145     479.0
2          60    103       135     340.0
3          45    109       175     282.4
4          45    117       148     406.0
5          60    102       127     300.0
6          60    110       136     374.0
7          45    104       134     253.3
8          30    109       133     195.1
9          60     98       124     269.0
10         60    103       147     329.3
11         60    100       120     250.7
12         60    106       128     345.3
13         60    104       132     379.3
14         60     98       123     275.0
15         60     98       120     215.2
16         60    100       120     300.0
17         45     90       112     300.0
18         60    103       123     323.0
19         45     97       125     243.0
20         60    108       131     364.2
21         45    100       119     282.0
22         60    130       101     300.0
23         45    105       132     246.0
24         60    102       126     334.5
25         60    100       120     250.0
26         60     92       118     241.0
27         60    103       132     300.0
28         60    100       132     280.0
29         60    102       129     380.3
30         60     92       115     243.0
31         45     90       112     180.1
32         60    101       124     299.0
33         60     93       113     223.0
34         60    107       136     361.0
35         60    114       140     415.0
36         60    102       127     300.0
37         60    100       120     300.0
38         60    100       120     300.0
39         45    104       129     266.0
40         45     90       112     180.1
41         60     98       126     286.0
42         60    100       122     329.4
43         60    111       138     400.0
44         60    111       131     397.0
45         60     99       119     273.0
46         60    109       153     387.6
47         45    111       136     300.0
48         45    108       129     298.0
49         60    111       139     397.6
50         60    107       136     380.2
51         80    123       146     643.1
52         60    106       130     263.0
53         60    118       151     486.0
54         30    136       175     238.0
55         60    121       146     450.7
56         60    118       121     413.0
57         45    115       144     305.0
58         20    153       172     226.4
59         45    123       152     321.0
60        210    108       160    1376.0
61        160    110       137    1034.4
62        160    109       135     853.0
63         45    118       141     341.0
64         20    110       130     131.4
65        180     90       130     800.4
66        150    105       135     873.4
67        150    107       130     816.0
68         20    106       136     110.4
69        300    108       143    1500.2
70        150     97       129    1115.0
71         60    109       153     387.6
72         90    100       127     700.0
73        150     97       127     953.2
74         45    114       146     304.0
75         90     98       125     563.2
76         45    105       134     251.0
77         45    110       141     300.0
78        120    100       130     500.4
79        270    100       131    1729.0
80         30    159       182     319.2
81         45    149       169     344.0
82         30    103       139     151.1
83        120    100       130     500.0
84         45    100       120     225.3
85         30    151       170     300.0
86         45    102       136     234.0
87        120    100       157    1000.1
88         45    129       103     242.0
89         20     83       107      50.3
90        180    101       127     600.1
91         45    107       137     300.0
92         30     90       107     105.3
93         15     80       100      50.5
94         20    150       171     127.4
95         20    151       168     229.4
96         30     95       128     128.2
97         25    152       168     244.2
98         30    109       131     188.2
99         90     93       124     604.1
100        20     95       112      77.7
101        90     90       110     500.0
102        90     90       100     500.0
103        90     90       100     500.4
104        30     92       108      92.7
105        30     93       128     124.0
106       180     90       120     800.3
107        30     90       120      86.2
108        90     90       120     500.3
109       210    137       184    1860.4
110        60    102       124     325.2
111        45    107       124     275.0
112        15    124       139     124.2
113        45    100       120     225.3
114        60    108       131     367.6
115        60    108       151     351.7
116        60    116       141     443.0
117        60     97       122     277.4
118        60    105       125     300.0
119        60    103       124     332.7
120        30    112       137     193.9
121        45    100       120     100.7
122        60    119       169     336.7
123        60    107       127     344.9
124        60    111       151     368.5
125        60     98       122     271.0
126        60     97       124     275.3
127        60    109       127     382.0
128        90     99       125     466.4
129        60    114       151     384.0
130        60    104       134     342.5
131        60    107       138     357.5
132        60    103       133     335.0
133        60    106       132     327.5
134        60    103       136     339.0
135        20    136       156     189.0
136        45    117       143     317.7
137        45    115       137     318.0
138        45    113       138     308.0
139        20    141       162     222.4
140        60    108       135     390.0
141        60     97       127     300.0
142        45    100       120     250.4
143        45    122       149     335.4
144        60    136       170     470.2
145        45    106       126     270.8
146        60    107       136     400.0
147        60    112       146     361.9
148        30    103       127     185.0
149        60    110       150     409.4
150        60    106       134     343.0
151        60    109       129     353.2
152        60    109       138     374.0
153        30    150       167     275.8
154        60    105       128     328.0
155        60    111       151     368.5
156        60     97       131     270.4
157        60    100       120     270.4
158        60    114       150     382.8
159        30     80       120     240.9
160        30     85       120     250.4
161        45     90       130     260.4
162        45     95       130     270.0
163        45    100       140     280.9
164        60    105       140     290.8
165        60    110       145     300.0
166        60    115       145     310.2
167        75    120       150     320.4
168        75    125       150     330.4
:END:
*** Cleaning Data of Wrong Format
#+BEGIN_SRC python
import pandas as pd

df = pd.read_csv('data1.csv')

df['Date'] = pd.to_datetime(df['Date'])

print(df.to_string())
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[13], line 5
      1 import pandas as pd
      3 df = pd.read_csv('data1.csv')
----> 5 df['Date'] = pd.to_datetime(df['Date'])
      7 print(df.to_string())

File ~/miniconda3/envs/scimax/lib/python3.11/site-packages/pandas/core/tools/datetimes.py:1112, in to_datetime(arg, errors, dayfirst, yearfirst, utc, format, exact, unit, infer_datetime_format, origin, cache)
   1110         result = arg.map(cache_array)
   1111     else:
-> 1112         values = convert_listlike(arg._values, format)
   1113         result = arg._constructor(values, index=arg.index, name=arg.name)
   1114 elif isinstance(arg, (ABCDataFrame, abc.MutableMapping)):

File ~/miniconda3/envs/scimax/lib/python3.11/site-packages/pandas/core/tools/datetimes.py:488, in _convert_listlike_datetimes(arg, format, name, utc, unit, errors, dayfirst, yearfirst, exact)
    486 # `format` could be inferred, or user didn't ask for mixed-format parsing.
    487 if format is not None and format != "mixed":
--> 488     return _array_strptime_with_fallback(arg, name, utc, format, exact, errors)
    490 result, tz_parsed = objects_to_datetime64ns(
    491     arg,
    492     dayfirst=dayfirst,
   (...)
    496     allow_object=True,
    497 )
    499 if tz_parsed is not None:
    500     # We can take a shortcut since the datetime64 numpy array
    501     # is in UTC

File ~/miniconda3/envs/scimax/lib/python3.11/site-packages/pandas/core/tools/datetimes.py:519, in _array_strptime_with_fallback(arg, name, utc, fmt, exact, errors)
    508 def _array_strptime_with_fallback(
    509     arg,
    510     name,
   (...)
    514     errors: str,
    515 ) -> Index:
    516     """
    517     Call array_strptime, with fallback behavior depending on 'errors'.
    518     """
--> 519     result, timezones = array_strptime(arg, fmt, exact=exact, errors=errors, utc=utc)
    520     if any(tz is not None for tz in timezones):
    521         return _return_parsed_timezone_results(result, timezones, utc, name)

File strptime.pyx:534, in pandas._libs.tslibs.strptime.array_strptime()

File strptime.pyx:355, in pandas._libs.tslibs.strptime.array_strptime()

ValueError: time data "20201226" doesn't match format "'%Y/%m/%d'", at position 26. You might want to try:
    - passing `format` if your strings have a consistent format;
    - passing `format='ISO8601'` if your strings are all ISO8601 but not necessarily in exactly the same format;
    - passing `format='mixed'`, and the format will be inferred for each element individually. You might want to use `dayfirst` alongside this.
:END:

*** Fixing Wrong Data
#+BEGIN_SRC python
import pandas as pd

df = pd.read_csv('data1.csv')

df.loc[7,'Duration'] = 45

print(df.to_string())
#+END_SRC

#+RESULTS:
:RESULTS:
    SN  Duration          Date  Pulse  Maxpulse  Calories
0    0        60  '2020/12/01'    110       130     409.1
1    1        60  '2020/12/02'    117       145     479.0
2    2        60  '2020/12/03'    103       135     340.0
3    3        45  '2020/12/04'    109       175     282.4
4    4        45  '2020/12/05'    117       148     406.0
5    5        60  '2020/12/06'    102       127     300.0
6    6        60  '2020/12/07'    110       136     374.0
7    7        45  '2020/12/08'    104       134     253.3
8    8        30  '2020/12/09'    109       133     195.1
9    9        60  '2020/12/10'     98       124     269.0
10  10        60  '2020/12/11'    103       147     329.3
11  11        60  '2020/12/12'    100       120     250.7
12  12        60  '2020/12/12'    100       120     250.7
13  13        60  '2020/12/13'    106       128     345.3
14  14        60  '2020/12/14'    104       132     379.3
15  15        60  '2020/12/15'     98       123     275.0
16  16        60  '2020/12/16'     98       120     215.2
17  17        60  '2020/12/17'    100       120     300.0
18  18        45  '2020/12/18'     90       112       NaN
19  19        60  '2020/12/19'    103       123     323.0
20  20        45  '2020/12/20'     97       125     243.0
21  21        60  '2020/12/21'    108       131     364.2
22  22        45           NaN    100       119     282.0
23  23        60  '2020/12/23'    130       101     300.0
24  24        45  '2020/12/24'    105       132     246.0
25  25        60  '2020/12/25'    102       126     334.5
26  26        60      20201226    100       120     250.0
27  27        60  '2020/12/27'     92       118     241.0
28  28        60  '2020/12/28'    103       132       NaN
29  29        60  '2020/12/29'    100       132     280.0
30  30        60  '2020/12/30'    102       129     380.3
31  31        60  '2020/12/31'     92       115     243.0
:END:
#+BEGIN_SRC python
import pandas as pd

df = pd.read_csv('data1.csv')

for x in df.index:
  if df.loc[x, "Duration"] > 120:
    df.loc[x, "Duration"] = 120

print(df.to_string())
#+END_SRC

#+RESULTS:
:RESULTS:
    SN  Duration          Date  Pulse  Maxpulse  Calories
0    0        60  '2020/12/01'    110       130     409.1
1    1        60  '2020/12/02'    117       145     479.0
2    2        60  '2020/12/03'    103       135     340.0
3    3        45  '2020/12/04'    109       175     282.4
4    4        45  '2020/12/05'    117       148     406.0
5    5        60  '2020/12/06'    102       127     300.0
6    6        60  '2020/12/07'    110       136     374.0
7    7       120  '2020/12/08'    104       134     253.3
8    8        30  '2020/12/09'    109       133     195.1
9    9        60  '2020/12/10'     98       124     269.0
10  10        60  '2020/12/11'    103       147     329.3
11  11        60  '2020/12/12'    100       120     250.7
12  12        60  '2020/12/12'    100       120     250.7
13  13        60  '2020/12/13'    106       128     345.3
14  14        60  '2020/12/14'    104       132     379.3
15  15        60  '2020/12/15'     98       123     275.0
16  16        60  '2020/12/16'     98       120     215.2
17  17        60  '2020/12/17'    100       120     300.0
18  18        45  '2020/12/18'     90       112       NaN
19  19        60  '2020/12/19'    103       123     323.0
20  20        45  '2020/12/20'     97       125     243.0
21  21        60  '2020/12/21'    108       131     364.2
22  22        45           NaN    100       119     282.0
23  23        60  '2020/12/23'    130       101     300.0
24  24        45  '2020/12/24'    105       132     246.0
25  25        60  '2020/12/25'    102       126     334.5
26  26        60      20201226    100       120     250.0
27  27        60  '2020/12/27'     92       118     241.0
28  28        60  '2020/12/28'    103       132       NaN
29  29        60  '2020/12/29'    100       132     280.0
30  30        60  '2020/12/30'    102       129     380.3
31  31        60  '2020/12/31'     92       115     243.0
:END:
#+BEGIN_SRC python
import pandas as pd

df = pd.read_csv('data.csv')

for x in df.index:
  if df.loc[x, "Duration"] > 120:
    df.drop(x, inplace = True)

#remember to include the 'inplace = True' argument to make the changes in the original DataFrame object instead of returning a copy

print(df.to_string())
#+END_SRC

#+RESULTS:
:RESULTS:
     Duration  Pulse  Maxpulse  Calories
0          60    110       130     409.1
1          60    117       145     479.0
2          60    103       135     340.0
3          45    109       175     282.4
4          45    117       148     406.0
5          60    102       127     300.0
6          60    110       136     374.0
7          45    104       134     253.3
8          30    109       133     195.1
9          60     98       124     269.0
10         60    103       147     329.3
11         60    100       120     250.7
12         60    106       128     345.3
13         60    104       132     379.3
14         60     98       123     275.0
15         60     98       120     215.2
16         60    100       120     300.0
17         45     90       112       NaN
18         60    103       123     323.0
19         45     97       125     243.0
20         60    108       131     364.2
21         45    100       119     282.0
22         60    130       101     300.0
23         45    105       132     246.0
24         60    102       126     334.5
25         60    100       120     250.0
26         60     92       118     241.0
27         60    103       132       NaN
28         60    100       132     280.0
29         60    102       129     380.3
30         60     92       115     243.0
31         45     90       112     180.1
32         60    101       124     299.0
33         60     93       113     223.0
34         60    107       136     361.0
35         60    114       140     415.0
36         60    102       127     300.0
37         60    100       120     300.0
38         60    100       120     300.0
39         45    104       129     266.0
40         45     90       112     180.1
41         60     98       126     286.0
42         60    100       122     329.4
43         60    111       138     400.0
44         60    111       131     397.0
45         60     99       119     273.0
46         60    109       153     387.6
47         45    111       136     300.0
48         45    108       129     298.0
49         60    111       139     397.6
50         60    107       136     380.2
51         80    123       146     643.1
52         60    106       130     263.0
53         60    118       151     486.0
54         30    136       175     238.0
55         60    121       146     450.7
56         60    118       121     413.0
57         45    115       144     305.0
58         20    153       172     226.4
59         45    123       152     321.0
63         45    118       141     341.0
64         20    110       130     131.4
68         20    106       136     110.4
71         60    109       153     387.6
72         90    100       127     700.0
74         45    114       146     304.0
75         90     98       125     563.2
76         45    105       134     251.0
77         45    110       141     300.0
78        120    100       130     500.4
80         30    159       182     319.2
81         45    149       169     344.0
82         30    103       139     151.1
83        120    100       130     500.0
84         45    100       120     225.3
85         30    151       170     300.0
86         45    102       136     234.0
87        120    100       157    1000.1
88         45    129       103     242.0
89         20     83       107      50.3
91         45    107       137       NaN
92         30     90       107     105.3
93         15     80       100      50.5
94         20    150       171     127.4
95         20    151       168     229.4
96         30     95       128     128.2
97         25    152       168     244.2
98         30    109       131     188.2
99         90     93       124     604.1
100        20     95       112      77.7
101        90     90       110     500.0
102        90     90       100     500.0
103        90     90       100     500.4
104        30     92       108      92.7
105        30     93       128     124.0
107        30     90       120      86.2
108        90     90       120     500.3
110        60    102       124     325.2
111        45    107       124     275.0
112        15    124       139     124.2
113        45    100       120     225.3
114        60    108       131     367.6
115        60    108       151     351.7
116        60    116       141     443.0
117        60     97       122     277.4
118        60    105       125       NaN
119        60    103       124     332.7
120        30    112       137     193.9
121        45    100       120     100.7
122        60    119       169     336.7
123        60    107       127     344.9
124        60    111       151     368.5
125        60     98       122     271.0
126        60     97       124     275.3
127        60    109       127     382.0
128        90     99       125     466.4
129        60    114       151     384.0
130        60    104       134     342.5
131        60    107       138     357.5
132        60    103       133     335.0
133        60    106       132     327.5
134        60    103       136     339.0
135        20    136       156     189.0
136        45    117       143     317.7
137        45    115       137     318.0
138        45    113       138     308.0
139        20    141       162     222.4
140        60    108       135     390.0
141        60     97       127       NaN
142        45    100       120     250.4
143        45    122       149     335.4
144        60    136       170     470.2
145        45    106       126     270.8
146        60    107       136     400.0
147        60    112       146     361.9
148        30    103       127     185.0
149        60    110       150     409.4
150        60    106       134     343.0
151        60    109       129     353.2
152        60    109       138     374.0
153        30    150       167     275.8
154        60    105       128     328.0
155        60    111       151     368.5
156        60     97       131     270.4
157        60    100       120     270.4
158        60    114       150     382.8
159        30     80       120     240.9
160        30     85       120     250.4
161        45     90       130     260.4
162        45     95       130     270.0
163        45    100       140     280.9
164        60    105       140     290.8
165        60    110       145     300.0
166        60    115       145     310.2
167        75    120       150     320.4
168        75    125       150     330.4
:END:

*** Removing Duplicates
#+BEGIN_SRC python
import pandas as pd

df = pd.read_csv('data1.csv')

print(df.duplicated())
#+END_SRC

#+RESULTS:
:RESULTS:
0     False
1     False
2     False
3     False
4     False
5     False
6     False
7     False
8     False
9     False
10    False
11    False
12     True
13    False
14    False
15    False
16    False
17    False
18    False
19    False
20    False
21    False
22    False
23    False
24    False
25    False
26    False
27    False
28    False
29    False
30    False
31    False
dtype: bool
:END:
#+BEGIN_SRC python
import pandas as pd

df = pd.read_csv('data1.csv')

df.drop_duplicates(inplace = True)

print(df.to_string())

#Notice that row 12 has been removed from the result
#+END_SRC

#+RESULTS:
:RESULTS:
    Duration          Date  Pulse  Maxpulse  Calories
0         60  '2020/12/01'    110       130     409.1
1         60  '2020/12/02'    117       145     479.0
2         60  '2020/12/03'    103       135     340.0
3         45  '2020/12/04'    109       175     282.4
4         45  '2020/12/05'    117       148     406.0
5         60  '2020/12/06'    102       127     300.0
6         60  '2020/12/07'    110       136     374.0
7        450  '2020/12/08'    104       134     253.3
8         30  '2020/12/09'    109       133     195.1
9         60  '2020/12/10'     98       124     269.0
10        60  '2020/12/11'    103       147     329.3
11        60  '2020/12/12'    100       120     250.7
13        60  '2020/12/13'    106       128     345.3
14        60  '2020/12/14'    104       132     379.3
15        60  '2020/12/15'     98       123     275.0
16        60  '2020/12/16'     98       120     215.2
17        60  '2020/12/17'    100       120     300.0
18        45  '2020/12/18'     90       112       NaN
19        60  '2020/12/19'    103       123     323.0
20        45  '2020/12/20'     97       125     243.0
21        60  '2020/12/21'    108       131     364.2
22        45           NaN    100       119     282.0
23        60  '2020/12/23'    130       101     300.0
24        45  '2020/12/24'    105       132     246.0
25        60  '2020/12/25'    102       126     334.5
26        60      20201226    100       120     250.0
27        60  '2020/12/27'     92       118     241.0
28        60  '2020/12/28'    103       132       NaN
29        60  '2020/12/29'    100       132     280.0
30        60  '2020/12/30'    102       129     380.3
31        60  '2020/12/31'     92       115     243.0
:END:

*** Data Correlations
- The corr() method calculates the relationship between each column in your data set.
- The Result of the corr() method is a table with a lot of numbers that represents how well the relationship is between two columns.
- The number varies from -1 to 1.
- 1 means that there is a 1 to 1 relationship (a perfect correlation), and for this data set, each time a value went up in the first column, the other one went up as well.
- 0.9 is also a good relationship, and if you increase one value, the other will probably increase as well.
- -0.9 would be just as good relationship as 0.9, but if you increase one value, the other will probably go down.
- 0.2 means NOT a good relationship, meaning that if one value goes up does not mean that the other will.
#+BEGIN_SRC python
import pandas as pd

df = pd.read_csv('data3.csv')

print(df.corr())
#+END_SRC

#+RESULTS:
:RESULTS:
          Duration     Pulse  Maxpulse  Calories
Duration  1.000000 -0.155408  0.009403  0.922717
Pulse    -0.155408  1.000000  0.786535  0.025121
Maxpulse  0.009403  0.786535  1.000000  0.203813
Calories  0.922717  0.025121  0.203813  1.000000
:END:

*** Plotting
#+BEGIN_SRC python
import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('data4.csv')

df.plot()

plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/8c4d2a58be072bdb117c1397ada9cfe3dcc33789.png]]
:END:
#+BEGIN_SRC python
import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('data4.csv')

df.plot(kind = 'scatter', x = 'Duration', y = 'Calories')

plt.show() 
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/020c69e5a9b3b02a5797f270f052e52c96ca6345.png]]
:END:
#+BEGIN_SRC python
import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('data4.csv')

df.plot(kind = 'scatter', x = 'Duration', y = 'Maxpulse')

plt.show() 
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/360becdc10d1be7a99b1908392c5c0b8ec6ac15f.png]]
:END:
#+BEGIN_SRC python
#Three lines to make our compiler able to draw:
import sys
import matplotlib
# matplotlib.use('Agg')

import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('data4.csv')

df["Duration"].plot(kind = 'hist')

plt.show()

#Two  lines to make our compiler able to draw:
# plt.savefig(sys.stdout.buffer)
# sys.stdout.flush()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/2a32a71c17f489b0813633e6be2bae4503d2023c.png]]
:END:

* SciPy
- SciPy :: Scientific Python is a scientific computation library that uses NumPy underneath. It provides more utility functions for optimization, stats and signal processing.
*** Version
#+BEGIN_SRC python
import scipy

print(scipy.__version__)
#+END_SRC

#+RESULTS:
: 1.11.3
*** SciPy Constants
- SciPy provides many built-in scientific constants.
#+BEGIN_SRC python
from scipy import constants

print(constants.pi) 
print(dir(constants)) 
#+END_SRC

#+RESULTS:
:RESULTS:
3.141592653589793
['Avogadro', 'Boltzmann', 'Btu', 'Btu_IT', 'Btu_th', 'ConstantWarning', 'G', 'Julian_year', 'N_A', 'Planck', 'R', 'Rydberg', 'Stefan_Boltzmann', 'Wien', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', '_codata', '_constants', '_obsolete_constants', 'acre', 'alpha', 'angstrom', 'arcmin', 'arcminute', 'arcsec', 'arcsecond', 'astronomical_unit', 'atm', 'atmosphere', 'atomic_mass', 'atto', 'au', 'bar', 'barrel', 'bbl', 'blob', 'c', 'calorie', 'calorie_IT', 'calorie_th', 'carat', 'centi', 'codata', 'constants', 'convert_temperature', 'day', 'deci', 'degree', 'degree_Fahrenheit', 'deka', 'dyn', 'dyne', 'e', 'eV', 'electron_mass', 'electron_volt', 'elementary_charge', 'epsilon_0', 'erg', 'exa', 'exbi', 'femto', 'fermi', 'find', 'fine_structure', 'fluid_ounce', 'fluid_ounce_US', 'fluid_ounce_imp', 'foot', 'g', 'gallon', 'gallon_US', 'gallon_imp', 'gas_constant', 'gibi', 'giga', 'golden', 'golden_ratio', 'grain', 'gram', 'gravitational_constant', 'h', 'hbar', 'hectare', 'hecto', 'horsepower', 'hour', 'hp', 'inch', 'k', 'kgf', 'kibi', 'kilo', 'kilogram_force', 'kmh', 'knot', 'lambda2nu', 'lb', 'lbf', 'light_year', 'liter', 'litre', 'long_ton', 'm_e', 'm_n', 'm_p', 'm_u', 'mach', 'mebi', 'mega', 'metric_ton', 'micro', 'micron', 'mil', 'mile', 'milli', 'minute', 'mmHg', 'mph', 'mu_0', 'nano', 'nautical_mile', 'neutron_mass', 'nu2lambda', 'ounce', 'oz', 'parsec', 'pebi', 'peta', 'physical_constants', 'pi', 'pico', 'point', 'pound', 'pound_force', 'precision', 'proton_mass', 'psi', 'pt', 'quecto', 'quetta', 'ronna', 'ronto', 'short_ton', 'sigma', 'slinch', 'slug', 'speed_of_light', 'speed_of_sound', 'stone', 'survey_foot', 'survey_mile', 'tebi', 'tera', 'test', 'ton_TNT', 'torr', 'troy_ounce', 'troy_pound', 'u', 'unit', 'value', 'week', 'yard', 'year', 'yobi', 'yocto', 'yotta', 'zebi', 'zepto', 'zero_Celsius', 'zetta']
:END:
#+BEGIN_SRC python
from scipy import constants
# Return the specified unit in meter (e.g. centi returns 0.01)
print(constants.yotta)    #1e+24
print(constants.zetta)    #1e+21
print(constants.exa)      #1e+18
print(constants.peta)     #1000000000000000.0
print(constants.tera)     #1000000000000.0
print(constants.giga)     #1000000000.0
print(constants.mega)     #1000000.0
print(constants.kilo)     #1000.0
print(constants.hecto)    #100.0
print(constants.deka)     #10.0
print(constants.deci)     #0.1
print(constants.centi)    #0.01
print(constants.milli)    #0.001
print(constants.micro)    #1e-06
print(constants.nano)     #1e-09
print(constants.pico)     #1e-12
print(constants.femto)    #1e-15
print(constants.atto)     #1e-18
print(constants.zepto)    #1e-21 
#+END_SRC

#+RESULTS:
:RESULTS:
1e+24
1e+21
1e+18
1000000000000000.0
1000000000000.0
1000000000.0
1000000.0
1000.0
100.0
10.0
0.1
0.01
0.001
1e-06
1e-09
1e-12
1e-15
1e-18
1e-21
:END:
#+BEGIN_SRC python
from scipy import constants
# Return the specified unit in bytes (e.g. kibi returns 1024)
print(constants.kibi)    #1024
print(constants.mebi)    #1048576
print(constants.gibi)    #1073741824
print(constants.tebi)    #1099511627776
print(constants.pebi)    #1125899906842624
print(constants.exbi)    #1152921504606846976
print(constants.zebi)    #1180591620717411303424
print(constants.yobi)    #1208925819614629174706176 
#+END_SRC

#+RESULTS:
:RESULTS:
1024
1048576
1073741824
1099511627776
1125899906842624
1152921504606846976
1180591620717411303424
1208925819614629174706176
:END:
#+BEGIN_SRC python
from scipy import constants
# Return the specified unit in kg (e.g. gram returns 0.001)
print(constants.gram)        #0.001
print(constants.metric_ton)  #1000.0
print(constants.grain)       #6.479891e-05
print(constants.lb)          #0.45359236999999997
print(constants.pound)       #0.45359236999999997
print(constants.oz)          #0.028349523124999998
print(constants.ounce)       #0.028349523124999998
print(constants.stone)       #6.3502931799999995
print(constants.long_ton)    #1016.0469088
print(constants.short_ton)   #907.1847399999999
print(constants.troy_ounce)  #0.031103476799999998
print(constants.troy_pound)  #0.37324172159999996
print(constants.carat)       #0.0002
print(constants.atomic_mass) #1.66053904e-27
print(constants.m_u)         #1.66053904e-27
print(constants.u)           #1.66053904e-27
#+END_SRC

#+RESULTS:
:RESULTS:
0.001
1000.0
6.479891e-05
0.45359236999999997
0.45359236999999997
0.028349523124999998
0.028349523124999998
6.3502931799999995
1016.0469088
907.1847399999999
0.031103476799999998
0.37324172159999996
0.0002
1.6605390666e-27
1.6605390666e-27
1.6605390666e-27
:END:
#+BEGIN_SRC python
from scipy import constants
# Return the specified unit in radians (e.g. degree returns 0.017453292519943295)
print(constants.degree)     #0.017453292519943295
print(constants.arcmin)     #0.0002908882086657216
print(constants.arcminute)  #0.0002908882086657216
print(constants.arcsec)     #4.84813681109536e-06
print(constants.arcsecond)  #4.84813681109536e-06 
#+END_SRC

#+RESULTS:
:RESULTS:
0.017453292519943295
0.0002908882086657216
0.0002908882086657216
4.84813681109536e-06
4.84813681109536e-06
:END:
#+BEGIN_SRC python
from scipy import constants
# Return the specified unit in seconds (e.g. hour returns 3600.0)
print(constants.minute)      #60.0
print(constants.hour)        #3600.0
print(constants.day)         #86400.0
print(constants.week)        #604800.0
print(constants.year)        #31536000.0
print(constants.Julian_year) #31557600.0 
#+END_SRC

#+RESULTS:
:RESULTS:
60.0
3600.0
86400.0
604800.0
31536000.0
31557600.0
:END:
#+BEGIN_SRC python
from scipy import constants
# Return the specified unit in meters (e.g. nautical_mile returns 1852.0)
print(constants.inch)              #0.0254
print(constants.foot)              #0.30479999999999996
print(constants.yard)              #0.9143999999999999
print(constants.mile)              #1609.3439999999998
print(constants.mil)               #2.5399999999999997e-05
print(constants.pt)                #0.00035277777777777776
print(constants.point)             #0.00035277777777777776
print(constants.survey_foot)       #0.3048006096012192
print(constants.survey_mile)       #1609.3472186944373
print(constants.nautical_mile)     #1852.0
print(constants.fermi)             #1e-15
print(constants.angstrom)          #1e-10
print(constants.micron)            #1e-06
print(constants.au)                #149597870691.0
print(constants.astronomical_unit) #149597870691.0
print(constants.light_year)        #9460730472580800.0
print(constants.parsec)            #3.0856775813057292e+16 
#+END_SRC

#+RESULTS:
:RESULTS:
0.0254
0.30479999999999996
0.9143999999999999
1609.3439999999998
2.5399999999999997e-05
0.00035277777777777776
0.00035277777777777776
0.3048006096012192
1609.3472186944373
1852.0
1e-15
1e-10
1e-06
149597870700.0
149597870700.0
9460730472580800.0
3.085677581491367e+16
:END:
#+BEGIN_SRC python
from scipy import constants
# Return the specified unit in pascals (e.g. psi returns 6894.757293168361)
print(constants.atm)         #101325.0
print(constants.atmosphere)  #101325.0
print(constants.bar)         #100000.0
print(constants.torr)        #133.32236842105263
print(constants.mmHg)        #133.32236842105263
print(constants.psi)         #6894.757293168361 
#+END_SRC

#+RESULTS:
:RESULTS:
101325.0
101325.0
100000.0
133.32236842105263
133.32236842105263
6894.757293168361
:END:
#+BEGIN_SRC python
from scipy import constants
# Return the specified unit in square meters(e.g. hectare returns 10000.0)
print(constants.hectare) #10000.0
print(constants.acre)    #4046.8564223999992 
#+END_SRC

#+RESULTS:
:RESULTS:
10000.0
4046.8564223999992
:END:
#+BEGIN_SRC python
from scipy import constants
# Return the specified unit in cubic meters (e.g. liter returns 0.001)
print(constants.liter)            #0.001
print(constants.litre)            #0.001
print(constants.gallon)           #0.0037854117839999997
print(constants.gallon_US)        #0.0037854117839999997
print(constants.gallon_imp)       #0.00454609
print(constants.fluid_ounce)      #2.9573529562499998e-05
print(constants.fluid_ounce_US)   #2.9573529562499998e-05
print(constants.fluid_ounce_imp)  #2.84130625e-05
print(constants.barrel)           #0.15898729492799998
print(constants.bbl)              #0.15898729492799998 
#+END_SRC

#+RESULTS:
:RESULTS:
0.001
0.001
0.0037854117839999997
0.0037854117839999997
0.00454609
2.9573529562499998e-05
2.9573529562499998e-05
2.84130625e-05
0.15898729492799998
0.15898729492799998
:END:
#+BEGIN_SRC python
from scipy import constants
# Return the specified unit in meters per second (e.g. speed_of_sound returns 340.5)
print(constants.kmh)            #0.2777777777777778
print(constants.mph)            #0.44703999999999994
print(constants.mach)           #340.5
print(constants.speed_of_sound) #340.5
print(constants.knot)           #0.5144444444444445 
#+END_SRC

#+RESULTS:
:RESULTS:
0.2777777777777778
0.44703999999999994
340.5
340.5
0.5144444444444445
:END:
#+BEGIN_SRC python
from scipy import constants
# Return the specified unit in Kelvin (e.g. zero_Celsius returns 273.15)
print(constants.zero_Celsius)      #273.15
print(constants.degree_Fahrenheit) #0.5555555555555556 
#+END_SRC

#+RESULTS:
:RESULTS:
273.15
0.5555555555555556
:END:
#+BEGIN_SRC python
from scipy import constants
# Return the specified unit in joules (e.g. calorie returns 4.184)
print(constants.eV)            #1.6021766208e-19
print(constants.electron_volt) #1.6021766208e-19
print(constants.calorie)       #4.184
print(constants.calorie_th)    #4.184
print(constants.calorie_IT)    #4.1868
print(constants.erg)           #1e-07
print(constants.Btu)           #1055.05585262
print(constants.Btu_IT)        #1055.05585262
print(constants.Btu_th)        #1054.3502644888888
print(constants.ton_TNT)       #4184000000.0 
#+END_SRC

#+RESULTS:
:RESULTS:
1.602176634e-19
1.602176634e-19
4.184
4.184
4.1868
1e-07
1055.05585262
1055.05585262
1054.3502644888888
4184000000.0
:END:
#+BEGIN_SRC python
from scipy import constants
# Return the specified unit in watts (e.g. horsepower returns 745.6998715822701)
print(constants.hp)         #745.6998715822701
print(constants.horsepower) #745.6998715822701 
#+END_SRC

#+RESULTS:
:RESULTS:
745.6998715822701
745.6998715822701
:END:
#+BEGIN_SRC python
from scipy import constants
# Return the specified unit in newton (e.g. kilogram_force returns 9.80665)
print(constants.dyn)             #1e-05
print(constants.dyne)            #1e-05
print(constants.lbf)             #4.4482216152605
print(constants.pound_force)     #4.4482216152605
print(constants.kgf)             #9.80665
print(constants.kilogram_force)  #9.80665 
#+END_SRC

#+RESULTS:
:RESULTS:
1e-05
1e-05
4.4482216152605
4.4482216152605
9.80665
9.80665
:END:
*** SciPy Optimizers
- Optimizers :: a set of procedures defined in SciPy that either find the minimum value of a function, or the root of an equation.
#+BEGIN_SRC python
from scipy.optimize import root
from math import cos

def eqn(x):
  return  x**2 + x + 2

myroot = root(eqn, 0)

print(myroot.x)
print(myroot)
#+END_SRC

#+RESULTS:
:RESULTS:
[-0.49999999]
 message: The iteration is not making good progress, as measured by the 
            improvement from the last ten iterations.
 success: False
  status: 5
     fun: [ 1.750e+00]
       x: [-5.000e-01]
    nfev: 19
    fjac: [[-1.000e+00]]
       r: [ 1.953e-03]
     qtf: [-1.750e+00]
:END:
#+BEGIN_SRC python
from scipy.optimize import minimize

def eqn(x):
  return x**2 + x + 2

mymin = minimize(eqn, 0, method='BFGS')

print(mymin)
#+END_SRC

#+RESULTS:
:RESULTS:
  message: Optimization terminated successfully.
  success: True
   status: 0
      fun: 1.75
        x: [-5.000e-01]
      nit: 2
      jac: [ 0.000e+00]
 hess_inv: [[ 5.000e-01]]
     nfev: 8
     njev: 4
:END:
*** SciPy Sparse Data
- Sparse data :: data that has mostly unused elements (elements that don't carry any information ).
- A data set where most of the item values are zero.
- Demse Array :: the opposite of a sparse array: most of the values are not zero.
- There are primarily two types of sparse matrices that we use:
  - CSC :: Compressed Sparse Column. For efficient arithmetic, fast column slicing.
  - CSR :: Compressed Sparse Row. For fast row slicing, faster matrix vector products
#+BEGIN_SRC python
import numpy as np
from scipy.sparse import csr_matrix

arr = np.array([0, 0, 0, 0, 0, 1, 1, 0, 2])

print(csr_matrix(arr))
#+END_SRC

#+RESULTS:
:RESULTS:
  (0, 5)	1
  (0, 6)	1
  (0, 8)	2
:END:
#+BEGIN_SRC python
import numpy as np
from scipy.sparse import csr_matrix

arr = np.array([[0, 0, 0], [0, 0, 1], [1, 0, 2]])

print(csr_matrix(arr).data)
print(csr_matrix(arr).count_nonzero())
#+END_SRC

#+RESULTS:
:RESULTS:
[1 1 2]
3
:END:
#+BEGIN_SRC python
import numpy as np
from scipy.sparse import csr_matrix

arr = np.array([[0, 0, 0], [0, 0, 1], [1, 0, 2]])

mat = csr_matrix(arr)
mat.eliminate_zeros()

print(mat) 
#+END_SRC

#+RESULTS:
:RESULTS:
  (1, 2)	1
  (2, 0)	1
  (2, 2)	2
:END:
#+BEGIN_SRC python
import numpy as np
from scipy.sparse import csr_matrix

arr = np.array([[0, 0, 0], [0, 0, 1], [1, 0, 2]])

mat = csr_matrix(arr)
mat.sum_duplicates()

print(mat)
#+END_SRC

#+RESULTS:
:RESULTS:
  (1, 2)	1
  (2, 0)	1
  (2, 2)	2
:END:
#+BEGIN_SRC python
import numpy as np
from scipy.sparse import csr_matrix

arr = np.array([[0, 0, 0], [0, 0, 1], [1, 0, 2]])

newarr = csr_matrix(arr).tocsc()

print(newarr)
#+END_SRC

#+RESULTS:
:RESULTS:
  (2, 0)	1
  (1, 2)	1
  (2, 2)	2
:END:

*** SciPy Graphs
**** Adjacency Matrix
**** Connected Components
#+BEGIN_SRC python
import numpy as np
from scipy.sparse.csgraph import connected_components
from scipy.sparse import csr_matrix

arr = np.array([
  [0, 1, 2],
  [1, 0, 0],
  [2, 0, 0]
])

newarr = csr_matrix(arr)

print(connected_components(newarr)) 
#+END_SRC

#+RESULTS:
:RESULTS:
(1, array([0, 0, 0], dtype=int32))
:END:
**** Dijkstra
#+BEGIN_SRC python
import numpy as np
from scipy.sparse.csgraph import dijkstra
from scipy.sparse import csr_matrix

arr = np.array([
  [0, 1, 2],
  [1, 0, 0],
  [2, 0, 0]
])

newarr = csr_matrix(arr)

print(dijkstra(newarr, return_predecessors=True, indices=0)) 
#+END_SRC

#+RESULTS:
:RESULTS:
(array([0., 1., 2.]), array([-9999,     0,     0], dtype=int32))
:END:
**** Floyd Warshall
#+BEGIN_SRC python
import numpy as np
from scipy.sparse.csgraph import floyd_warshall
from scipy.sparse import csr_matrix

arr = np.array([
  [0, 1, 2],
  [1, 0, 0],
  [2, 0, 0]
])

newarr = csr_matrix(arr)

print(floyd_warshall(newarr, return_predecessors=True)) 
#+END_SRC

#+RESULTS:
:RESULTS:
(array([[0., 1., 2.],
       [1., 0., 3.],
       [2., 3., 0.]]), array([[-9999,     0,     0],
       [    1, -9999,     0],
       [    2,     0, -9999]], dtype=int32))
:END:
**** Bellman Ford
#+BEGIN_SRC python
import numpy as np
from scipy.sparse.csgraph import bellman_ford
from scipy.sparse import csr_matrix

arr = np.array([
  [0, -1, 2],
  [1, 0, 0],
  [2, 0, 0]
])

newarr = csr_matrix(arr)

print(bellman_ford(newarr, return_predecessors=True, indices=0)) 
#+END_SRC

#+RESULTS:
:RESULTS:
(array([ 0., -1.,  2.]), array([-9999,     0,     0], dtype=int32))
:END:
**** Depth First Order
#+BEGIN_SRC python
import numpy as np
from scipy.sparse.csgraph import depth_first_order
from scipy.sparse import csr_matrix

arr = np.array([
  [0, 1, 0, 1],
  [1, 1, 1, 1],
  [2, 1, 1, 0],
  [0, 1, 0, 1]
])

newarr = csr_matrix(arr)

print(depth_first_order(newarr, 1)) 
#+END_SRC

#+RESULTS:
:RESULTS:
(array([1, 0, 3, 2], dtype=int32), array([    1, -9999,     1,     0], dtype=int32))
:END:
**** Breadth First Order
#+BEGIN_SRC python
import numpy as np
from scipy.sparse.csgraph import breadth_first_order
from scipy.sparse import csr_matrix

arr = np.array([
  [0, 1, 0, 1],
  [1, 1, 1, 1],
  [2, 1, 1, 0],
  [0, 1, 0, 1]
])

newarr = csr_matrix(arr)

print(breadth_first_order(newarr, 1)) 
#+END_SRC

#+RESULTS:
:RESULTS:
(array([1, 0, 2, 3], dtype=int32), array([    1, -9999,     1,     1], dtype=int32))
:END:

*** SciPy Spatial Data
- Spatial Data :: data that is represented in a geometric space.
**** Triangulation
- Triangulation of a polygon :: divide the polygon into multiple triangles with which we can compute an area of the polygon.
- Triangulation with points :: creating surface composed triangles in which all of the given points are on at least one vertex of any triangle in the surface.
#+BEGIN_SRC python
import numpy as np
from scipy.spatial import Delaunay
import matplotlib.pyplot as plt

points = np.array([
  [2, 4],
  [3, 4],
  [3, 0],
  [2, 2],
  [4, 1]
])

simplices = Delaunay(points).simplices

plt.triplot(points[:, 0], points[:, 1], simplices) # The simplices property creates a generalization of the triangle notation.
plt.scatter(points[:, 0], points[:, 1], color='r')

plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/fffd2d0d17245ec221f0665b7abe2ff43f3daace.png]]
:END:
**** Convex Hull
- Convex Hull :: smallest polygon that covers all of the given points.
#+BEGIN_SRC python
import numpy as np
from scipy.spatial import ConvexHull
import matplotlib.pyplot as plt
# Create a convex hull for following points:
points = np.array([
  [2, 4],
  [3, 4],
  [3, 0],
  [2, 2],
  [4, 1],
  [1, 2],
  [5, 0],
  [3, 1],
  [1, 2],
  [0, 2]
])

hull = ConvexHull(points)
hull_points = hull.simplices

plt.scatter(points[:,0], points[:,1])
for simplex in hull_points:
  plt.plot(points[simplex,0], points[simplex,1], 'k-')

plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/52b66f6b55da86c8b3f30389c5f06457cab39d7f.png]]
:END:
**** KDTrees
- KDTrees :: a datastructure optimized for nearest neighbor queries.
- For example, in a set of points using KDTrees we can efficiently ask which points are nearest to a certain given point.
#+BEGIN_SRC python
from scipy.spatial import KDTree
import matplotlib.pyplot as plt
# Find the nearest neighbor to point (1,1):
points = [(1, -1), (2, 3), (-2, 3), (2, -3)]

kdtree = KDTree(points)

res = kdtree.query((1, 1))

print(res)

zip(*points)
plt.scatter(*zip(*points))
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
(2.0, 0)
[[file:./.ob-jupyter/77686a448daee94c89a3738caebbeecc37955201.png]]
:END:

**** Distance Matrix
***** Euclidean Distance
#+BEGIN_SRC python
from scipy.spatial.distance import euclidean

p1 = (1, 0)
p2 = (10, 2)

res = euclidean(p1, p2)

print(res)
#+END_SRC

#+RESULTS:
:RESULTS:
9.219544457292887
:END:

***** Cityblock Distance (Manhattan Distance)
- Cityblock Distance (Manhattan Distance) :: distance computed using 4 degrees of movement.
- E.g. we can only move: up, down, right, or left, not diagonally.
#+BEGIN_SRC python
from scipy.spatial.distance import cityblock

p1 = (1, 0)
p2 = (10, 2)

res = cityblock(p1, p2)

print(res)
#+END_SRC

#+RESULTS:
:RESULTS:
11
:END:

***** Cosine Distance
- Cosine Distance :: the value of cosine angle between the two points A and B.
#+BEGIN_SRC python
from scipy.spatial.distance import cosine

p1 = (1, 0)
p2 = (10, 2)

res = cosine(p1, p2)

print(res)
#+END_SRC

#+RESULTS:
:RESULTS:
0.019419324309079777
:END:

***** Hamming Distance
- Hamming distance :: he proportion of bits where two bits are different.
- It's a way to measure distance for binary sequences.
#+BEGIN_SRC python
from scipy.spatial.distance import hamming

p1 = (True, False, True)
p2 = (False, True, True)

res = hamming(p1, p2)

print(res)
#+END_SRC

#+RESULTS:
:RESULTS:
0.6666666666666666
:END:

*** SciPy Interpolation
- Interpolation :: a method for generating points between given points.
- For example: for points 1 and 2, we may interpolate and find points 1.33 and 1.66.
- Interpolation has many usage, in Machine Learning we often deal with missing data in a dataset, interpolation is often used to substitute those values.
- This method of filling values is called imputation.
- Apart from imputation, interpolation is often used where we need to smooth the discrete points in a dataset.
**** 1D Interpolation
#+BEGIN_SRC python
from scipy.interpolate import interp1d
import numpy as np
# For given xs and ys interpolate values from 2.1, 2.2... to 2.9:
xs = np.arange(10)
ys = 2*xs + 1

interp_func = interp1d(xs, ys)

newarr = interp_func(np.arange(2.1, 3, 0.1))

print(newarr)
#+END_SRC

#+RESULTS:
:RESULTS:
[5.2 5.4 5.6 5.8 6.  6.2 6.4 6.6 6.8]
:END:
**** Spline Interpolation
- In 1D interpolation the points are fitted for a single curve whereas in Spline interpolation the points are fitted against a piecewise function defined with polynomials called splines.
- Piecewise function :: A function that has different definition for different ranges.
#+BEGIN_SRC python
from scipy.interpolate import UnivariateSpline
import numpy as np

xs = np.arange(10)
ys = xs**2 + np.sin(xs) + 1

interp_func = UnivariateSpline(xs, ys)

newarr = interp_func(np.arange(2.1, 3, 0.1))

print(newarr) 
#+END_SRC

#+RESULTS:
:RESULTS:
[5.62826474 6.03987348 6.47131994 6.92265019 7.3939103  7.88514634
 8.39640439 8.92773053 9.47917082]
:END:
**** Interpolation with Radial Basis Function
- Radial basis function :: a function that is defined corresponding to a fixed reference point.
#+BEGIN_SRC python
from scipy.interpolate import Rbf
import numpy as np
# Interpolate following xs and ys using rbf and find values for 2.1, 2.2 ... 2.9:
xs = np.arange(10)
ys = xs**2 + np.sin(xs) + 1

interp_func = Rbf(xs, ys)

newarr = interp_func(np.arange(2.1, 3, 0.1))

print(newarr)
#+END_SRC

#+RESULTS:
:RESULTS:
[6.25748981 6.62190817 7.00310702 7.40121814 7.8161443  8.24773402
 8.69590519 9.16070828 9.64233874]
:END:
*** SciPy Statistical Significance Tests
**** T-Test
- T-tests are used to determine if there is significant deference between means of two variables and lets us know if they belong to the same distribution.
- It is a two tailed test.
#+BEGIN_SRC python
import numpy as np
from scipy.stats import ttest_ind

v1 = np.random.normal(size=100)
v2 = np.random.normal(size=100)

res = ttest_ind(v1, v2)

print(res)
#+END_SRC

#+RESULTS:
:RESULTS:
TtestResult(statistic=-0.33706246168668713, pvalue=0.7364268298927393, df=198.0)
:END:
**** KS-Test
- KS test is used to check if given values follow a distribution.
- The function takes the value to be tested, and the CDF as two parameters.
- A CDF can be either a string or a callable function that returns the probability.
- It can be used as a one tailed or two tailed test.
- By default it is two tailed. We can pass parameter alternative as a string of one of two-sided, less, or greater.
#+BEGIN_SRC python
import numpy as np
from scipy.stats import kstest
# Find if the given value follows the normal distribution:
v = np.random.normal(size=100)

res = kstest(v, 'norm')

print(res)
#+END_SRC

#+RESULTS:
:RESULTS:
KstestResult(statistic=0.06162810067586966, pvalue=0.819321927008103, statistic_location=0.6693751468733256, statistic_sign=1)
:END:
**** Statistical Description of Data
#+BEGIN_SRC python
import numpy as np
from scipy.stats import describe
# Show statistical description of the values in an array:
v = np.random.normal(size=100)
res = describe(v)

print(res)
#+END_SRC

#+RESULTS:
:RESULTS:
DescribeResult(nobs=100, minmax=(-3.2423664484367394, 2.7507561234865427), mean=0.09075333320185329, variance=1.0747691347587753, skewness=-0.08733795979030937, kurtosis=0.3155197694513001)
:END:
**** Normality Tests (Skewness and Kurtosis)
- Normality Tests :: based on the skewness and kurtosis.
- Skewness :: a measure of symmetry in data. If it is negative, it means the data is skewed left. If it is positive it means the data is skewed right.
- Kurtosis :: a measure of whether the data is heavy or lightly tailed to a normal distribution. Positive kurtosis means heavy tailed. Negative kurtosis means lightly tailed.
#+BEGIN_SRC python
import numpy as np
from scipy.stats import skew, kurtosis

v = np.random.normal(size=100)

print(skew(v))
print(kurtosis(v))
#+END_SRC

#+RESULTS:
:RESULTS:
-0.3191800760193528
0.574106625699196
:END:

#+BEGIN_SRC python
import numpy as np
from scipy.stats import normaltest

v = np.random.normal(size=100)

print(normaltest(v)) 
#+END_SRC

#+RESULTS:
:RESULTS:
NormaltestResult(statistic=4.446043878906215, pvalue=0.10828139409046983)
:END:
* Numpy Arrays - Numerical Operations
*** Scalars
#+BEGIN_SRC python
import numpy as np
lst = [2,3, 7.9, 3.3, 6.9, 0.11, 10.3, 12.9]
v = np.array(lst)
v = v + 2
print(v)
print(v * 2.2)
print(v - 1.38)
print(v ** 2)
print(v ** 1.5)

lst = [2,3, 7.9, 3.3, 6.9, 0.11, 10.3, 12.9]
res = []
for val in lst:
    res.append(val + 2)

print(res)

res1 = [ val + 2 for val in lst]
print(res1)

v1 = np.random.randint(0, 100, 1000)
%timeit v1 + 1

lst = list(v)
%timeit [ val + 2 for val in lst]
#+END_SRC

#+RESULTS:
:RESULTS:
[ 4.    5.    9.9   5.3   8.9   2.11 12.3  14.9 ]
[ 8.8   11.    21.78  11.66  19.58   4.642 27.06  32.78 ]
[ 2.62  3.62  8.52  3.92  7.52  0.73 10.92 13.52]
[ 16.      25.      98.01    28.09    79.21     4.4521 151.29   222.01  ]
[ 8.         11.18033989 31.14962279 12.2015163  26.55125232  3.06495204
 43.13776768 57.51477202]
[4, 5, 9.9, 5.3, 8.9, 2.11, 12.3, 14.9]
[4, 5, 9.9, 5.3, 8.9, 2.11, 12.3, 14.9]
1.18 µs ± 3.3 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)
565 ns ± 4.85 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)
:END:

*** Arithmetic Operations with two Arrays
#+BEGIN_SRC python
import numpy as np

A = np.array([ [11, 12, 13], [21, 22, 23], [31, 32, 33] ])
B = np.ones((3,3))

print("Array A: ")
print(A)

print("Array B: ")
print(B)

print("Adding to arrays: ")
print(A + B)

print("\nMultiplying two arrays: ") # "A * B" in the shouldn't be mistaken for matrix multiplication. The elements are solely component-wise multiplied.
print(A * (B + 1))
#+END_SRC

#+RESULTS:
:RESULTS:
Array A: 
[[11 12 13]
 [21 22 23]
 [31 32 33]]
Array B: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Adding to arrays: 
[[12. 13. 14.]
 [22. 23. 24.]
 [32. 33. 34.]]

Multiplying two arrays: 
[[22. 24. 26.]
 [42. 44. 46.]
 [62. 64. 66.]]
:END:

*** Matrix Multiplication
#+BEGIN_SRC python
# Check dimension matching for matrix multiplication. Shape of the last dimension of 'a' must be the same size as the shape of the second-to-last dimension of 'b'
print(A.shape[-1] == B.shape[-2])

np.dot(A, B)
#+END_SRC

#+RESULTS:
:RESULTS:
True
array([[36., 36., 36.],
       [66., 66., 66.],
       [96., 96., 96.]])
:END:

#+BEGIN_SRC python
print(np.dot(3, 4))
x = np.array([3])
y = np.array([4])
print(x.ndim)
print(np.dot(x, y))

x = np.array([3, -2])
y = np.array([-4, 1])
print(np.dot(x, y))
#+END_SRC

#+RESULTS:
:RESULTS:
12
1
12
-14
:END:
#+BEGIN_SRC python
A = np.array([ [1, 2, 3], 
               [3, 2, 1] ])
B = np.array([ [2, 3, 4, -2], 
               [1, -1, 2, 3],
               [1, 2, 3, 0] ])

# it must apply:
print(A.shape[-1] == B.shape[-2], A.shape[1]) 
print(np.dot(A, B))
#+END_SRC

#+RESULTS:
:RESULTS:
True 3
[[ 7  7 17  4]
 [ 9  9 19  0]]
:END:
#+BEGIN_SRC python
import numpy as np
X = np.array(
    [[[3, 1, 2],
      [4, 2, 2]],

     [[-1, 0, 1],
      [1, -1, -2]],
     
     [[3, 2, 2],
      [4, 4, 3]],

     [[2, 2, 1],
      [3, 1, 3]]])

Y = np.array(
    [[[2, 3, 1, 2, 1],
      [2, 2, 2, 0, 0],
      [3, 4, 0, 1, -1]],

     [[1, 4, 3, 2, 2],
      [4, 1, 1, 4, -3],
      [4, 1, 0, 3, 0]]])


R = np.dot(X, Y)



print("X.shape: ", X.shape, "   X.ndim: ", X.ndim)
print("Y.shape: ", Y.shape, "   Y.ndim: ", Y.ndim)
print("R.shape: ",     R.shape, "R.ndim: ", R.ndim)


print("\nThe result array R:\n")
print(R)
#+END_SRC

#+RESULTS:
:RESULTS:
X.shape:  (4, 2, 3)    X.ndim:  3
Y.shape:  (2, 3, 5)    Y.ndim:  3
R.shape:  (4, 2, 2, 5) R.ndim:  4

The result array R:

[[[[ 14  19   5   8   1]
   [ 15  15  10  16   3]]

  [[ 18  24   8  10   2]
   [ 20  20  14  22   2]]]


 [[[  1   1  -1  -1  -2]
   [  3  -3  -3   1  -2]]

  [[ -6  -7  -1   0   3]
   [-11   1   2  -8   5]]]


 [[[ 16  21   7   8   1]
   [ 19  16  11  20   0]]

  [[ 25  32  12  11   1]
   [ 32  23  16  33  -4]]]


 [[[ 11  14   6   5   1]
   [ 14  11   8  15  -2]]

  [[ 17  23   5   9   0]
   [ 19  16  10  19   3]]]]
:END:
#+BEGIN_SRC python
i = 0
for j in range(X.shape[1]):
    for k in range(Y.shape[0]):
        for m in range(Y.shape[2]):
            fmt = "    sum(X[{}, {}, :] * Y[{}, :, {}] :  {}"
            arguments = (i, j, k, m, sum(X[i, j, :] * Y[k, :, m]))
            print(fmt.format(*arguments))

print(R[0])
#+END_SRC

#+RESULTS:
:RESULTS:
    sum(X[0, 0, :] * Y[0, :, 0] :  14
    sum(X[0, 0, :] * Y[0, :, 1] :  19
    sum(X[0, 0, :] * Y[0, :, 2] :  5
    sum(X[0, 0, :] * Y[0, :, 3] :  8
    sum(X[0, 0, :] * Y[0, :, 4] :  1
    sum(X[0, 0, :] * Y[1, :, 0] :  15
    sum(X[0, 0, :] * Y[1, :, 1] :  15
    sum(X[0, 0, :] * Y[1, :, 2] :  10
    sum(X[0, 0, :] * Y[1, :, 3] :  16
    sum(X[0, 0, :] * Y[1, :, 4] :  3
    sum(X[0, 1, :] * Y[0, :, 0] :  18
    sum(X[0, 1, :] * Y[0, :, 1] :  24
    sum(X[0, 1, :] * Y[0, :, 2] :  8
    sum(X[0, 1, :] * Y[0, :, 3] :  10
    sum(X[0, 1, :] * Y[0, :, 4] :  2
    sum(X[0, 1, :] * Y[1, :, 0] :  20
    sum(X[0, 1, :] * Y[1, :, 1] :  20
    sum(X[0, 1, :] * Y[1, :, 2] :  14
    sum(X[0, 1, :] * Y[1, :, 3] :  22
    sum(X[0, 1, :] * Y[1, :, 4] :  2
[[[14 19  5  8  1]
  [15 15 10 16  3]]

 [[18 24  8 10  2]
  [20 20 14 22  2]]]
:END:
#+BEGIN_SRC python
R2 = np.zeros(R.shape, dtype=np.int8)
print(R2)

for i in range(X.shape[0]):
    for j in range(X.shape[1]):
        for k in range(Y.shape[0]):
            for m in range(Y.shape[2]):
                R2[i, j, k, m] = sum(X[i, j, :] * Y[k, :, m])


print( np.array_equal(R, R2) )
#+END_SRC

#+RESULTS:
:RESULTS:
[[[[0 0 0 0 0]
   [0 0 0 0 0]]

  [[0 0 0 0 0]
   [0 0 0 0 0]]]


 [[[0 0 0 0 0]
   [0 0 0 0 0]]

  [[0 0 0 0 0]
   [0 0 0 0 0]]]


 [[[0 0 0 0 0]
   [0 0 0 0 0]]

  [[0 0 0 0 0]
   [0 0 0 0 0]]]


 [[[0 0 0 0 0]
   [0 0 0 0 0]]

  [[0 0 0 0 0]
   [0 0 0 0 0]]]]
True
:END:

*** Matrices vs. Two-Dimensional Arrays
#+BEGIN_SRC python
import numpy as np

A = np.array([ [1, 2, 3], [2, 2, 2], [3, 3, 3] ])
B = np.array([ [3, 2, 1], [1, 2, 3], [-1, -2, -3] ])

R = A * B
print(R)
#+END_SRC

#+RESULTS:
:RESULTS:
[[ 3  4  3]
 [ 2  4  6]
 [-3 -6 -9]]
:END:
#+BEGIN_SRC python
# Turn a two-dimensional array into a "real" matrix by applying the "mat" function.
MA = np.mat(A)
MB = np.mat(B)

R = MA * MB
print(R)
#+END_SRC

#+RESULTS:
:RESULTS:
[[ 2  0 -2]
 [ 6  4  2]
 [ 9  6  3]]
:END:

*** Comparison Operators
#+BEGIN_SRC python
import numpy as np

A = np.array([ [11, 12, 13], [21, 22, 23], [31, 32, 33] ])
B = np.array([ [11, 102, 13], [201, 22, 203], [31, 32, 303] ])

# comparisons performed elementswise
print(A == B)

# compare complete arrays for equality
print(np.array_equal(A, B))
print(np.array_equal(A, A))
#+END_SRC

#+RESULTS:
:RESULTS:
[[ True False  True]
 [False  True False]
 [ True  True False]]
False
True
:END:

*** Logical Operators
#+BEGIN_SRC python
a = np.array([ [True, True], [False, False]])
b = np.array([ [True, False], [True, False]])

print(np.logical_or(a, b))
print(np.logical_and(a, b))
#+END_SRC

#+RESULTS:
:RESULTS:
[[ True  True]
 [ True False]]
[[ True False]
 [False False]]
:END:

*** Broadcasting
- We have a smaller array and a larger array, and we transform or apply the smaller array multiple times to perform some operation on the larger array. 
- Under certain conditions, the smaller array is "broadcasted" in a way that it has the same shape as the larger array.
#+BEGIN_SRC python
import numpy as np

A = np.array([ [11, 12, 13], [21, 22, 23], [31, 32, 33] ])
B = np.array([1, 2, 3])

print("A: ")
print(A)
print("B: ")
print(B)
print("Multiplication with broadcasting: ")
print(A * B)
print("... and now addition with broadcasting: ")
print(A + B)
#+END_SRC

#+RESULTS:
:RESULTS:
A: 
[[11 12 13]
 [21 22 23]
 [31 32 33]]
B: 
[1 2 3]
Multiplication with broadcasting: 
[[11 24 39]
 [21 44 69]
 [31 64 99]]
... and now addition with broadcasting: 
[[12 14 16]
 [22 24 26]
 [32 34 36]]
:END:

#+BEGIN_SRC python  
# turn a row vector into a column vector:
B = np.array([1, 2, 3])
B[:, np.newaxis]
#+END_SRC

#+RESULTS:
:RESULTS:
array([[1],
       [2],
       [3]])
:END:


#+BEGIN_SRC python  
import numpy as np

A = np.array([ [11, 12, 13], [21, 22, 23], [31, 32, 33] ])
B = np.array([1, 2, 3])
A * B[:, np.newaxis]
#+END_SRC

#+RESULTS:
:RESULTS:
array([[11, 12, 13],
       [42, 44, 46],
       [93, 96, 99]])
:END:


#+BEGIN_SRC python  
A = np.array([10, 20, 30])
B = np.array([1, 2, 3])
A[:, np.newaxis]

A[:, np.newaxis] * B
#+END_SRC

#+RESULTS:
:RESULTS:
array([[10, 20, 30],
       [20, 40, 60],
       [30, 60, 90]])
:END:


#+BEGIN_SRC python  
import numpy as np

A = np.array([ [11, 12, 13], [21, 22, 23], [31, 32, 33] ])

B = np.tile(np.array([1, 2, 3]), (3, 1))

print(B)

print("Multiplication: ")
print(A * B)
print("... and now addition again: ")
print(A + B)
#+END_SRC

#+RESULTS:
:RESULTS:
[[1 2 3]
 [1 2 3]
 [1 2 3]]
Multiplication: 
[[11 24 39]
 [21 44 69]
 [31 64 99]]
... and now addition again: 
[[12 14 16]
 [22 24 26]
 [32 34 36]]
:END:

*** Distance Matrix
#+BEGIN_SRC python  
cities = ["Barcelona", "Berlin", "Brussels", "Bucharest",
          "Budapest", "Copenhagen", "Dublin", "Hamburg", "Istanbul",
          "Kiev", "London", "Madrid", "Milan", "Moscow", "Munich",
          "Paris", "Prague", "Rome", "Saint Petersburg", 
          "Stockholm", "Vienna", "Warsaw"]

dist2barcelona = [0, 1498, 1063, 1968, 
                  1498, 1758, 1469, 1472, 2230, 
                  2391, 1138, 505, 725, 3007, 1055, 
                  833, 1354, 857, 2813, 
                  2277, 1347, 1862]

dists =  np.array(dist2barcelona[:12])
print(dists)
print(np.abs(dists - dists[:, np.newaxis]))
#+END_SRC

#+RESULTS:
:RESULTS:
[   0 1498 1063 1968 1498 1758 1469 1472 2230 2391 1138  505]
[[   0 1498 1063 1968 1498 1758 1469 1472 2230 2391 1138  505]
 [1498    0  435  470    0  260   29   26  732  893  360  993]
 [1063  435    0  905  435  695  406  409 1167 1328   75  558]
 [1968  470  905    0  470  210  499  496  262  423  830 1463]
 [1498    0  435  470    0  260   29   26  732  893  360  993]
 [1758  260  695  210  260    0  289  286  472  633  620 1253]
 [1469   29  406  499   29  289    0    3  761  922  331  964]
 [1472   26  409  496   26  286    3    0  758  919  334  967]
 [2230  732 1167  262  732  472  761  758    0  161 1092 1725]
 [2391  893 1328  423  893  633  922  919  161    0 1253 1886]
 [1138  360   75  830  360  620  331  334 1092 1253    0  633]
 [ 505  993  558 1463  993 1253  964  967 1725 1886  633    0]]
:END:


#+BEGIN_SRC python  
A = np.array([ [[3, 4, 7], [5, 0, -1] , [2, 1, 5]],
      [[1, 0, -1], [8, 2, 4], [5, 2, 1]],
      [[2, 1, 3], [1, 9, 4], [5, -2, 4]]])

B = np.array([ [[3, 4, 7], [1, 0, -1], [1, 2, 3]] ])

B * A
#+END_SRC

#+RESULTS:
:RESULTS:
#+begin_example
array([[[ 9, 16, 49],
        [ 5,  0,  1],
        [ 2,  2, 15]],

       [[ 3,  0, -7],
        [ 8,  0, -4],
        [ 5,  4,  3]],

       [[ 6,  4, 21],
        [ 1,  0, -4],
        [ 5, -4, 12]]])
#+end_example
:END:

#+BEGIN_SRC python  
B = np.array([1, 2, 3])

B = B[np.newaxis, :]
print(B.shape)
B = np.concatenate((B, B, B)).transpose()
print(B.shape)
B = B[:, np.newaxis]
print(B.shape)
print(B)

print(A * B)
#+END_SRC

#+RESULTS:
:RESULTS:
(1, 3)
(3, 3)
(3, 1, 3)
[[[1 1 1]]

 [[2 2 2]]

 [[3 3 3]]]
[[[ 3  4  7]
  [ 5  0 -1]
  [ 2  1  5]]

 [[ 2  0 -2]
  [16  4  8]
  [10  4  2]]

 [[ 6  3  9]
  [ 3 27 12]
  [15 -6 12]]]
:END:

* Numpy Arrays - Dimensions
*** Flatten and Reshape Arrays
- Flatten :: a ndarry method with an optional keyword parameter "order". Order can have the values "C", "F" and "A".
#+BEGIN_SRC python  
import numpy as np

A = np.array([[[ 0,  1],
               [ 2,  3],
               [ 4,  5],
               [ 6,  7]],
              [[ 8,  9],
               [10, 11],
               [12, 13],
               [14, 15]],
              [[16, 17],
               [18, 19],
               [20, 21],
               [22, 23]]])

Flattened_X = A.flatten()
print(Flattened_X)

# The default of order is "C". "C" means to flatten C style in row-major ordering, i.e. the rightmost index "changes the fastest" or in other words: In row-major order, the row index varies the slowest, and the column index the quickest, so that a[0,1] follows [0,0].
print(A.flatten(order="C"))
# "F" stands for Fortran column-major ordering.
print(A.flatten(order="F"))
# "A" means preserve the the C/Fortran ordering.
print(A.flatten(order="A"))
#+END_SRC

#+RESULTS:
:RESULTS:
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
[ 0  8 16  2 10 18  4 12 20  6 14 22  1  9 17  3 11 19  5 13 21  7 15 23]
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
:END:

- Ravel :: returns a flattened one-dimensional array. A copy is made only if needed.
The optional keyword parameter "order" can be 'C','F', 'A', or 'K'
- 'C': C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. "C" is the default!
- 'F': Fortran-like index order with the first index changing fastest, and the last index changing slowest.
- 'A': Fortran-like index order if the array "a" is Fortran contiguous in memory, C-like order otherwise.
- 'K': read the elements in the order they occur in memory, except for reversing the data when strides are negative.
#+BEGIN_SRC python  
print(A.ravel())

print(A.ravel(order="A"))

print(A.ravel(order="F"))

print(A.ravel(order="A"))

print(A.ravel(order="K"))
#+END_SRC

#+RESULTS:
:RESULTS:
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
[ 0  8 16  2 10 18  4 12 20  6 14 22  1  9 17  3 11 19  5 13 21  7 15 23]
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
:END:

- reshape :: The method reshape() gives a new shape to an array without changing its data, i.e. it returns a new array with a new shape.
#+BEGIN_SRC python  
X = np.array(range(24))
Y = X.reshape((3,4,2))
Y
#+END_SRC

#+RESULTS:
:RESULTS:
#+begin_example
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5],
        [ 6,  7]],

       [[ 8,  9],
        [10, 11],
        [12, 13],
        [14, 15]],

       [[16, 17],
        [18, 19],
        [20, 21],
        [22, 23]]])
#+end_example
:END:

*** Concatenating Arrays
#+BEGIN_SRC python  
x = np.array([11,22])
y = np.array([18,7,6])
z = np.array([1,3,5])
c = np.concatenate((x,y,z))
print(c)
#+END_SRC

#+RESULTS:
:RESULTS:
[11 22 18  7  6  1  3  5]
:END:

- If we are concatenating multidimensional arrays, we can concatenate the arrays according to axis. Arrays must have the same shape to be concatenated with concatenate().
- In the case of multidimensional arrays, we can arrange them according to the axis. The default value is axis = 0.
#+BEGIN_SRC python  
x = np.array(range(24))
x = x.reshape((3,4,2))
y = np.array(range(100,124))
y = y.reshape((3,4,2))
z = np.concatenate((x,y))
print(z)
#+END_SRC

#+RESULTS:
:RESULTS:
[[[  0   1]
  [  2   3]
  [  4   5]
  [  6   7]]

 [[  8   9]
  [ 10  11]
  [ 12  13]
  [ 14  15]]

 [[ 16  17]
  [ 18  19]
  [ 20  21]
  [ 22  23]]

 [[100 101]
  [102 103]
  [104 105]
  [106 107]]

 [[108 109]
  [110 111]
  [112 113]
  [114 115]]

 [[116 117]
  [118 119]
  [120 121]
  [122 123]]]
:END:


#+BEGIN_SRC python  
# same concatenation now with axis=1:
z = np.concatenate((x,y), axis = 1)
print(z)
#+END_SRC

#+RESULTS:
:RESULTS:
[[[  0   1]
  [  2   3]
  [  4   5]
  [  6   7]
  [100 101]
  [102 103]
  [104 105]
  [106 107]]

 [[  8   9]
  [ 10  11]
  [ 12  13]
  [ 14  15]
  [108 109]
  [110 111]
  [112 113]
  [114 115]]

 [[ 16  17]
  [ 18  19]
  [ 20  21]
  [ 22  23]
  [116 117]
  [118 119]
  [120 121]
  [122 123]]]
:END:

*** Adding New Dimensions
#+BEGIN_SRC python  
x = np.array([2,5,18,14,4])
y = x[:, np.newaxis]
print(y)
#+END_SRC

#+RESULTS:
:RESULTS:
[[ 2]
 [ 5]
 [18]
 [14]
 [ 4]]
:END:

*** Vector Stacking
#+BEGIN_SRC python  
A = np.array([3, 4, 5])
B = np.array([1, 9, 0])

print(np.row_stack((A, B)))

print(np.column_stack((A, B)))
np.shape(A)
#+END_SRC

#+RESULTS:
:RESULTS:
[[3 4 5]
 [1 9 0]]
[[3 1]
 [4 9]
 [5 0]]
| 3 |
:END:


#+BEGIN_SRC python  
A = np.array([[3, 4, 5],
              [1, 9, 0],
              [4, 6, 8]])
np.column_stack((A, A, A))
#+END_SRC

#+RESULTS:
:RESULTS:
array([[3, 4, 5, 3, 4, 5, 3, 4, 5],
       [1, 9, 0, 1, 9, 0, 1, 9, 0],
       [4, 6, 8, 4, 6, 8, 4, 6, 8]])
:END:


#+BEGIN_SRC python  
np.dstack((A, A, A))
#+END_SRC

#+RESULTS:
:RESULTS:
#+begin_example
array([[[3, 3, 3],
        [4, 4, 4],
        [5, 5, 5]],

       [[1, 1, 1],
        [9, 9, 9],
        [0, 0, 0]],

       [[4, 4, 4],
        [6, 6, 6],
        [8, 8, 8]]])
#+end_example
:END:

*** Repeating Patterns, The "tile" Method
#+BEGIN_SRC python  
import numpy as np
x = np.array([ [1, 2], [3, 4]])
np.tile(x, (3,4))
#+END_SRC

#+RESULTS:
:RESULTS:
array([[1, 2, 1, 2, 1, 2, 1, 2],
       [3, 4, 3, 4, 3, 4, 3, 4],
       [1, 2, 1, 2, 1, 2, 1, 2],
       [3, 4, 3, 4, 3, 4, 3, 4],
       [1, 2, 1, 2, 1, 2, 1, 2],
       [3, 4, 3, 4, 3, 4, 3, 4]])
:END:


#+BEGIN_SRC python  
import numpy as np

x = np.array([ 3.4])

y = np.tile(x, (5,)) 

print(y)
#+END_SRC

#+RESULTS:
:RESULTS:
[3.4 3.4 3.4 3.4 3.4]
:END:


#+BEGIN_SRC python  
import numpy as np
x = np.array([[1, 2], [3, 4]])
print(np.tile(x, 2))
#+END_SRC

#+RESULTS:
:RESULTS:
[[1 2 1 2]
 [3 4 3 4]]
:END:


#+BEGIN_SRC python  
import numpy as np
x = np.array([[1, 2], [3, 4]])
print(np.tile(x, (2, 1)))
#+END_SRC

#+RESULTS:
:RESULTS:
[[1 2]
 [3 4]
 [1 2]
 [3 4]]
:END:


#+BEGIN_SRC python  
import numpy as np
x = np.array([[1, 2], [3, 4]])
print(np.tile(x, (2, 2)))
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python  

#+END_SRC

* Password
-----BEGIN PGP MESSAGE-----

jA0ECQMCNGw45956Ghn/0kQB8nnjoIkDL3gD7cocT4Fg5Qk2JIyIRVvIYpZ3SrA2
aGqPxLUm1cYTl/lYkqkji2dDlP0wQ7vzX6OxRHhzQXsiYmYDOw==
=6n2U
-----END PGP MESSAGE-----
* Nix and NixOS
- NixOS, a Linux distribution built on top of the Nix package manager, can be described as "OS as Code." It employs declarative Nix configuration files to describe the entire state of the operating system.
- NixOS primarily focuses on managing the static portion of the system state in a declarative manner. Dynamic data, along with the contents in the user's home directory, remain unaffected by NixOS when rolling back to a previous generation.(although only the state declared in Nix configuration files can be rolled back).
- NixOS uses declarative configuration to manage the entire system environment. These configurations can be managed directly with Git, allowing the system to be restored to any historical state as long as the configuration files are preserved (provided the desired states are declared in the Nix configuration).
- Nix Flakes further enhance reproducibility by utilizing a flake.lock version lock file, which records the data source addresses, hash values, and other relevant information for all dependencies. This design greatly improves Nix's reproducibility and ensures consistent build results. It draws inspiration from package management designs in programming languages like Cargo and npm.
- Each software package in Nix has a unique hash, which is incorporated into its installation path, allowing multiple versions to coexist.
- NixOS is suitable for developers with a certain level of Linux usage experience and programming knowledge who desire greater control over their systems.
* Nix Language
** Intro
- The Nix language is designed for conveniently creating and composing derivations – precise descriptions of how contents of existing files are used to derive new files.
- It is a domain-specific, purely functional, lazily evaluated, dynamically typed programming language.
- A piece of Nix language code is a Nix expression.
- Evaluating a Nix expression produces a Nix value.
- The content of a Nix file (file extension .nix) is a Nix expression.
** Evaluating Nix files
#+BEGIN_SRC sh 
echo 1 + 2 > file.nix
nix-instantiate --eval file.nix
#+END_SRC

#+RESULTS:
: 3


#+BEGIN_SRC sh  
echo "{ a.b.c = 1; }" > file.nix
nix-instantiate --eval --strict file.nix
#+END_SRC

#+RESULTS:
: { a = { b = { c = 1; }; }; }

** Notes on whitespace
#+BEGIN_SRC nix 
let
 x = 1;
 y = 2;
in x + y
#+END_SRC

#+RESULTS:
: 3


#+BEGIN_SRC nix  
let x=1;y=2;in x+y
#+END_SRC

#+RESULTS:
: 3

** Recursive attribute set rec { ... }
#+BEGIN_SRC nix  
rec {
  one = 1;
  two = one + 1;
  three = two + 1;
}
#+END_SRC

#+RESULTS:
: { one = 1; three = <CODE>; two = <CODE>; }

** let ... in ...
#+BEGIN_SRC nix  
let
  b = a + 1;
  a = 1;
in
a + b
#+END_SRC

#+RESULTS:
: 3

** Attribute access
#+BEGIN_SRC nix  
let
  attrset = { x = 1; };
in
attrset.x
#+END_SRC

#+RESULTS:
: 1


#+BEGIN_SRC nix  
let
  attrset = { a = { b = { c = 1; }; }; };
in
attrset.a.b.c
#+END_SRC

#+RESULTS:
: 1


#+BEGIN_SRC nix  
{ a.b.c = 1; }
#+END_SRC

#+RESULTS:
: { a = <CODE>; }

** with ...; ...
#+BEGIN_SRC nix  
let
  a = {
    x = 1;
    y = 2;
    z = 3;
  };
in
with a; [ x y z ]
#+END_SRC

#+RESULTS:
: [ 1 2 3 ]

** inherit ...
#+BEGIN_SRC nix
let
  x = 1;
  y = 2;
in
{
  inherit x y;
}
#+END_SRC

#+RESULTS:
: { x = 1; y = 2; }


#+BEGIN_SRC nix
let
  a = { x = 1; y = 2; };
in
{
  inherit (a) x y;
}
#+END_SRC

#+RESULTS:
: { x = 1; y = 2; }


#+BEGIN_SRC nix  
let
  inherit ({ x = 1; y = 2; }) x y;
in [ x y ]
#+END_SRC

#+RESULTS:
: [ 1 2 ]

** String interpolation ${ ... }
#+BEGIN_SRC nix  
let
  name = "Nix";
in
"hello ${name}"
#+END_SRC

#+RESULTS:
: "hello Nix"

#+BEGIN_SRC nix  
let
  a = "no";
in
"${a + " ${a + " ${a}"}"}"
#+END_SRC

#+RESULTS:
: "no no no"

#+BEGIN_SRC nix  
let
  out = "Nix";
in
"echo ${out} > $out"
#+END_SRC

#+RESULTS:
: "echo Nix > $out"

** File system paths
#+BEGIN_SRC nix  
./.
#+END_SRC

#+RESULTS:
: /tmp/babel-wHbTkD

#+BEGIN_SRC nix  
../.
#+END_SRC

#+RESULTS:
: /tmp

** Lookup Paths
#+BEGIN_SRC nix  
<nixpkgs>
#+END_SRC

#+RESULTS:
: /home/thinky/.nix-defexpr/channels/nixpkgs


#+BEGIN_SRC nix  
<nixpkgs/lib>
#+END_SRC

#+RESULTS:
: /home/thinky/.nix-defexpr/channels/nixpkgs/lib

** Indented Strings
#+BEGIN_SRC nix  
''
multi
line
string
''
#+END_SRC

#+RESULTS:
: "multi\nline\nstring\n"


#+BEGIN_SRC nix  
''
  one
   two
    three
''
#+END_SRC

#+RESULTS:
: "one\n two\n  three\n"

** Functions
#+BEGIN_SRC nix  
x: x + 1
#+END_SRC

#+RESULTS:
: <LAMBDA>


#+BEGIN_SRC nix  
let
  f = x: x + 1;
in f
#+END_SRC

#+RESULTS:
: <LAMBDA>


#+BEGIN_SRC nix  
let
  f = x: x + 1;
in f 1
#+END_SRC

#+RESULTS:
: 2


#+BEGIN_SRC nix  
let
  f = x: x.a;
in
f { a = 1; }
#+END_SRC

#+RESULTS:
: 1


#+BEGIN_SRC nix  
let
  f = x: x.a;
  v = { a = 2; };
in
f v
#+END_SRC

#+RESULTS:
: 2


#+BEGIN_SRC nix  
(x: x + 1) 2
#+END_SRC

#+RESULTS:
: 3

- apply f to a, and put the result in a list. The resulting list has one element.
#+BEGIN_SRC nix  
let
 f = x: x + 1;
 a = 1;
in [ (f a) ]
#+END_SRC

#+RESULTS:
: [ 2 ]

- put f and a in a list. The resulting list has two elements.
#+BEGIN_SRC nix  
let
 f = x: x + 1;
 a = 1;
in [ f a ]
#+END_SRC

#+RESULTS:
: [ <LAMBDA> 1 ]

** Multiple Arguments
#+BEGIN_SRC nix  

#+END_SRC

